{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to <code>flepimop2</code>","text":"<p>The next generation of the flexible epidemic modeling pipeline.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Initialized <code>flepimop2</code>.</li> <li>Added <code>flepimop2</code> CLI and associated infrastructure, most of which is not public except the <code>flepimop2.logging</code> module.</li> <li>Added documentation using <code>mkdocs</code> that includes API/CLI reference as well as reusing <code>CHANGELOG.md</code> and <code>CONTRIBUTING.md</code> where appropriate.</li> <li>Added basic configuration models to parse and serialize configuration files. These are contained in the <code>flepimop2.configuration</code> module.</li> <li>Added core simulation infrastructure including engines (machinery to evolve a model) and systems (descriptions of model changes). These are contained in the <code>flepimop2.engine/system/backend</code> modules.</li> <li>Added the ability to execute auxiliary commands in the context of <code>flepimop2</code> with the <code>flepimop2 process</code> CLI backed by the <code>flepimop.process</code> module.</li> </ul>"},{"location":"development/adding-a-new-cli-command/","title":"Adding A New CLI Command","text":""},{"location":"development/adding-a-new-cli-command/#adding-a-new-cli-command","title":"Adding A New CLI Command","text":"<p>This tutorial will show how to:</p> <ul> <li>Add a new command to the <code>flepimop2</code> CLI.</li> <li>Add a new option to <code>flepimop2</code>'s CLI infrastructure.</li> <li>Test the newly added command.</li> </ul> <p>In this tutorial will demonstrate adding a new command called <code>flepimop2 hello</code> which will print hello world a user specified number of times.</p>"},{"location":"development/adding-a-new-cli-command/#brief-overview-of-flepimop2s-cli-infrastructure","title":"Brief Overview Of <code>flepimop2</code>'s CLI Infrastructure","text":"<p><code>flepimop2</code>'s CLI infrastructure might be a bit heavier and stricter than previous CLI programs a developer has worked with. The reason for this is to enforce consistency for the inputs and outputs of CLI commands. The primary restrictions of this approach are:</p> <ul> <li>CLI commands must implement a common abstract base class which provides a common framework for command implementations.</li> <li>Options/arguments are shared among all CLI commands so they have the same meaning and usage across commands. Developers cannot add bespoke options/arguments for their command.</li> <li>CLI outputs are made consistent via a common logging infrastructure so the outputs of commands have a common feel across the <code>flepimop2</code> CLI.</li> </ul> <p><code>flepimop2</code>'s CLI infrastructure is contained in the private <code>flepimop2._cli</code> subpackage. The most important elements of this subpackage are:</p> <ul> <li><code>CliCommand</code>: The abstract base class that CLI commands must implement. The main benefit of having CLI commands subclass a common class is that repeated logic can be consolidated, CLI inputs/outputs can be made consistent, and development work can be eased.</li> <li><code>COMMON_OPTIONS</code>: A constant dictionary mapping option/argument names to their definitions. CLI commands can request options/arguments from this dictionary by having them as keyword only arguments to their <code>run</code> method. The main benefit of this approach is that commands cannot define bespoke options/arguments and developers are forced to use consistent meanings across commands. I.e. the <code>--dry-run</code> option means the same thing in all commands.</li> <li><code>register_command</code>: The function that attaches a user's implementation of <code>CliCommand</code> to the <code>flepimop2</code> CLI.</li> </ul> <p>This infrastructure utilizes <code>click</code> so it may be helpful to reference their documentation occasionally. </p>"},{"location":"development/adding-a-new-cli-command/#adding-the-flepimop2-hello-command","title":"Adding The <code>flepimop2 hello</code> Command","text":"<p>In particular this tutorial will be add a new command to the <code>flepimop2</code> CLI called <code>hello</code> which will take a new number argument. The end result of this tutorial will be:</p> <pre><code>$ flepimop2 --help\nUsage: flepimop2 [OPTIONS] COMMAND [ARGS]...\n\n  flepimop2 - Flexible Epidemic Modeling Pipeline (version 2).\n\nOptions:\n  --version  Show the version and exit.\n  --help     Show this message and exit.\n\nCommands:\n  build     Compile and build a model defined in a configuration file.\n  hello     This command says hello a specified number of times.\n  process   Execute a processing step based on a configuration file.\n  simulate  Run simulations based on a configuration file.\n$ flepimop2 hello --help\nUsage: flepimop2 hello [OPTIONS] [TIMES]\n\n  This command says hello a specified number of times.\n\nOptions:\n  --dry-run        Should this command be run using dry run?\n  -v, --verbosity  The verbosity level to use for this command.\n  --help           Show this message and exit.\n</code></pre>"},{"location":"development/adding-a-new-cli-command/#add-the-hellocommand-class","title":"Add The <code>HelloCommand</code> Class","text":"<p>The first step is to implement the <code>HelloCommand</code> class in a new <code>src/flepimop2/_cli/_hello_command.py</code> file.</p> <pre><code>\"\"\"Hello command implementation.\"\"\"\n\n__all__ = []\n\n\nfrom flepimop2._cli._cli_command import CliCommand\n\n\nclass HelloCommand(CliCommand):\n    \"\"\"This command says hello a specified number of times.\"\"\"\n\n    def run(self, *, times: int, dry_run: bool) -&gt; None:  # type: ignore[override]\n        \"\"\"\n        Say hello a specified number of times.\n\n        Args:\n            times: The number of times to say hello.\n            dry_run: Whether dry run mode is enabled.\n        \"\"\"\n        if dry_run:\n            self.info(f\"Would said hello {times} time(s).\")\n            return\n        for i in range(times):\n            self.info(f\"({i + 1}/{times}) Hello, world!\")\n</code></pre> <p>The <code>run</code> method contains the logic of the command and it's keyword arguments correspond to the options/arguments requested from <code>COMMON_OPTIONS</code>. The <code>CliCommand</code> also provides consistent logging infrastructure in the form of the <code>log</code>, <code>debug</code>, <code>info</code>, <code>warning</code>, <code>error</code>, and <code>critical</code> methods. Note that a <code>verbosity</code> option is not explicitly requested, this option is added by default to the command and <code>CliCommand</code> handles translating the given verbosity to a logging level so developers only need to concern themselves with calling the appropriate logging method. To ease development the class docstring will be used as the help string for the command and the command's name is extracted from the class name.</p>"},{"location":"development/adding-a-new-cli-command/#adding-a-new-option","title":"Adding A New Option","text":"<p>The implementation of <code>flepimop2 hello</code> needs a times argument. To add this argument a developer needs to add it to the <code>COMMON_OPTIONS</code> dictionary in <code>src/flepimop2/_cli/_options.py</code>.</p> <pre><code># Dictionary of common Click options and arguments\n# These can be requested by command classes to maintain consistency\nCOMMON_OPTIONS: Final = {\n    ...\n    \"times\": click.argument(\n        \"times\",\n        type=click.IntRange(min=1),\n        default=1,\n        required=False,\n    ),\n    ...\n}\n</code></pre> <p>This adds a new <code>times</code> argument to the <code>COMMON_OPTIONS</code> dictionary. Note that the argument is not tied specifically to the <code>flepimop2 hello</code> command since this argument could be used by other commands.</p>"},{"location":"development/adding-a-new-cli-command/#register-the-new-command","title":"Register The New Command","text":"<p>The final step is to register the new command with the <code>flepimop2</code> CLI by adding a call to <code>register_command</code> in <code>src/flepimop2/_cli/_cli.py</code>.</p> <pre><code>...\nfrom flepimop2._cli._build_command import BuildCommand\nfrom flepimop2._cli._hello_command import HelloCommand\nfrom flepimop2._cli._process_command import ProcessCommand\n...\n# Register all commands\nregister_command(BuildCommand, cli)\nregister_command(SimulateCommand, cli)\nregister_command(ProcessCommand, cli)\nregister_command(HelloCommand, cli)\n</code></pre> <p>The <code>register_command</code> function takes the CLI command class as it's first argument and the <code>click.Group</code> to attach the command to. In this case the command is being attached to the main cli, <code>cli</code>, so it can be invoked <code>flepimop2 hello</code>. But one could have created a new click group so one could have nested subcommands, i.e. <code>flepimop2 greetings hello</code>.</p>"},{"location":"development/adding-a-new-cli-command/#testing-a-new-command","title":"Testing A New Command","text":"<p>Before preparing this command for a PR it's important to test the new command. There are two types of testing:</p> <ol> <li>Ad-hoc testing: Testing the command manually for expected behavior.</li> <li>Unit testing: Programmatically testing the command.</li> </ol>"},{"location":"development/adding-a-new-cli-command/#ad-hoc-testing","title":"Ad-Hoc Testing","text":"<p>The first pass for testing a new command should be ad-hoc testing because it's the easiest way to get feedback during development. This entails running the command several times and manually checking that the output matches the expected.</p> <pre><code>$ flepimop2 hello --help\nUsage: flepimop2 hello [OPTIONS] [TIMES]\n\n  This command says hello a specified number of times.\n\nOptions:\n  --dry-run        Should this command be run using dry run?\n  -v, --verbosity  The verbosity level to use for this command.\n  --help           Show this message and exit.\n$ flepimop2 hello 3\n$ flepimop2 hello -v 3\n$ flepimop2 hello -vv 3\n2025-11-06 09:48:40,962:INFO&gt; (1/3) Hello, world!\n2025-11-06 09:48:40,962:INFO&gt; (2/3) Hello, world!\n2025-11-06 09:48:40,962:INFO&gt; (3/3) Hello, world!\n$ flepimop2 hello -vvv 3\n2025-11-06 09:48:46,452:DEBUG&gt; Given 2 options/arguments:\n2025-11-06 09:48:46,452:DEBUG&gt; times   = 3.\n2025-11-06 09:48:46,452:DEBUG&gt; dry_run = 0.\n2025-11-06 09:48:46,452:INFO&gt; (1/3) Hello, world!\n2025-11-06 09:48:46,452:INFO&gt; (2/3) Hello, world!\n2025-11-06 09:48:46,452:INFO&gt; (3/3) Hello, world!\n$ flepimop2 hello -vv --dry-run 5\n2025-11-06 09:49:00,106:INFO&gt; Would said hello 5 time(s).\n$ flepimop2 hello 0\nUsage: flepimop2 hello [OPTIONS] [TIMES]\nTry 'flepimop2 hello --help' for help.\n\nError: Invalid value for '[TIMES]': 0 is not in the range x&gt;=1.\n</code></pre> <p>This quick ad-hoc testing matches the following expected behavior:</p> <ul> <li>The command should only produce output at <code>-vv</code> and above because it uses the <code>info</code> method to log output.</li> <li>The command says \"Hello, world!\" the number of times given.</li> <li>Providing <code>--dry-run</code> does not repeat the greeting, but instead says it would have done so.</li> <li>Providing 0 or less for times results in an error that is caught before the command can run.</li> </ul>"},{"location":"development/adding-a-new-cli-command/#unit-testing","title":"Unit Testing","text":"<p>Ad-hoc testing is great for development purposes or diagnosing bugs quickly, but is not sustainable for long term maintenance. However, writing unit tests for CLI commands can be especially tricky because much of what CLI commands do is glue together behavior from other objects and emit output. Before unit testing a CLI command a developer should ask the following:</p> <ol> <li>Can this behavior and corresponding unit test be pushed down to the object being operated on or a new function? For example, suppose that <code>flepimop2 hello</code> worked with the <code>RunMeta</code> object and formatted the timestamp for display. In this case the formatting behavior should be added to the <code>RunMeta</code> object and tested there instead of testing that behavior via <code>HelloCommand</code>.</li> <li>Is the behavior essential to the CLI command? For example, the output logged to the user is non-essential. <code>flepimop2</code> does not make guarantees about CLI output consistency across versions. The only case where one might want to test the logged output is to see if a particular branch was reached, i.e. a certain message is only emitted if certain conditions are met.</li> </ol> <p>With that being said, the <code>flepimop2 hello</code> command does not have behavior that would be worth unit testing. For the purposes of unit testing change the <code>HelloCommand.run</code> method to:</p> <pre><code>...\n    def run(self, *, times: int, dry_run: bool) -&gt; None:  # type: ignore[override]\n        \"\"\"\n        Say hello a specified number of times.\n\n        Args:\n            times: The number of times to say hello.\n            dry_run: Whether dry run mode is enabled.\n\n        Raises:\n            ValueError: If `times` is greater than 10.\n        \"\"\"\n        if times &gt; 10:\n            msg = \"Cannot say hello more than 10 times.\"\n            raise ValueError(msg)\n        if dry_run:\n            self.info(f\"Would said hello {times} time(s).\")\n            return\n        for i in range(times):\n            self.info(f\"({i + 1}/{times}) Hello, world!\")\n</code></pre> <p>Now the command has behavior, raising an exception, that is worth testing and cannot be pushed to the object being operated on or an external function. To unit test this behavior add the following to <code>tests/_cli/test_hello_command.py</code>:</p> <pre><code>\"\"\"Unit tests for the `flepimop2 hello` CLI command.\"\"\"\n\nfrom flepimop2._cli._hello_command import HelloCommand\nimport pytest\n\n\ndef test_raises_value_error_if_times_exceeds_limit() -&gt; None:\n    \"\"\"Test that ValueError is raised if times &gt; 10.\"\"\"\n    command = HelloCommand()\n    with pytest.raises(ValueError, match=r\"Cannot say hello more than 10 times.\"):\n        command.run(times=11, dry_run=False)\n</code></pre> <p>Another benefit to <code>flepimop2</code>'s CLI infrastructure is that the <code>run</code> method of a <code>CliCommand</code> subclass can be tested directly rather than needing to use <code>subprocess.run</code> or <code>click.testing.CliRunner</code>. If the verbosity level needs to be controlled for a unit test a developer could modify this test by invoking <code>HelloCommand.__call__</code> instead with the same arguments as <code>run</code> but including verbosity like so:</p> <pre><code>\"\"\"Unit tests for the `flepimop2 hello` CLI command.\"\"\"\n\nfrom flepimop2._cli._hello_command import HelloCommand\nimport pytest\n\n\ndef test_raises_value_error_if_times_exceeds_limit() -&gt; None:\n    \"\"\"Test that ValueError is raised if times &gt; 10.\"\"\"\n    command = HelloCommand()\n    with pytest.raises(ValueError, match=r\"Cannot say hello more than 10 times.\"):\n        command(times=11, dry_run=False, verbosity=0)\n</code></pre>"},{"location":"development/adding-a-new-cli-command/#summary","title":"Summary","text":"<p>This tutorial covered:</p> <ul> <li>A high level overview of the <code>flepimop2</code> CLI infrastructure.</li> <li>Adding a new command to the <code>flepimop2</code> CLI.</li> <li>Adding a new option to <code>flepimop2</code>'s CLI infrastructure.</li> <li>Testing the newly added command.</li> </ul>"},{"location":"development/contributing/","title":"Contributing to <code>flepimop2</code>","text":"<p>This document provides guidelines and instructions for contributing to <code>flepimop2</code>, including development conventions and tips for best practices.</p>"},{"location":"development/contributing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Development Setup</li> <li>Code Standards</li> <li>Testing</li> <li>Documentation</li> <li>Pull Request Process</li> <li>Reporting Issues</li> </ul>"},{"location":"development/contributing/#development-setup","title":"Development Setup","text":""},{"location":"development/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11, 3.12, 3.13, or 3.14.</li> <li><code>uv</code> - Python package manager.</li> <li><code>just</code> - Command runner (optional but strongly recommended).</li> </ul>"},{"location":"development/contributing/#initial-setup","title":"Initial Setup","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone git@github.com:ACCIDDA/flepimop2.git\ncd flepimop2\n</code></pre> <ol> <li>Create a virtual environment and install dependencies:</li> </ol> <pre><code>uv sync --dev\n</code></pre> <p>This creates a <code>.venv</code> virtual environment and installs the package along with all development dependencies (mypy, pytest, ruff, mkdocs). If you need to create an environment with a specific python version you can also run:</p> <pre><code>uv sync --dev --python 3.12\n</code></pre> <ol> <li>Verify your setup</li> </ol> <pre><code>just\n</code></pre> <p>This runs the default development checks:</p> <ul> <li><code>ruff format</code> - Format code.</li> <li><code>ruff check --fix</code> - Lint and auto-fix issues.</li> <li><code>pytest --doctest-modules</code> - Run tests including doctests.</li> <li><code>mypy --strict</code> - Type check with strict settings.</li> <li><code>yamllint --strict</code> - Lint YAML files.</li> </ul> <p>It is recommended that you run this command frequently as you do development work to catch issues early.</p>"},{"location":"development/contributing/#code-standards","title":"Code Standards","text":""},{"location":"development/contributing/#style","title":"Style","text":"<p>We use <code>ruff</code> for both formatting and linting:</p> <ul> <li>Formatting: <code>ruff format</code> follows the Black code style.</li> <li>Linting: <code>ruff check</code> enforces code quality rules.</li> </ul> <p>Run <code>just</code> to automatically format and lint your code before committing. Or you can run <code>just format</code> and <code>just check</code> to run just these steps.</p>"},{"location":"development/contributing/#testing","title":"Testing","text":""},{"location":"development/contributing/#organization","title":"Organization","text":"<p>Tests are organized to mirror the source code structure:</p> <pre><code>tests/\n|-- {module}/\n|   |-- {submodule}/\n|   |   |-- test_{function}.py     # Tests for individual functions\n|   |   |-- test_{class}_class.py  # Tests for classes\n|   |-- test_{function}.py\n</code></pre> <p>Examples:</p> <ul> <li><code>tests/logging/test_get_script_logger.py</code> - Tests for the <code>get_script_logger</code> function.</li> <li><code>tests/logging/test_click_handler_class.py</code> - Tests for the <code>ClickHandler</code> class.</li> <li><code>tests/_cli/_options/test_get_option.py</code> - Tests for the <code>get_option</code> function.</li> <li><code>tests/configuration/test_fixed_parameter_specification_model_class.py</code> - Tests for the <code>FixedParameterSpecificationModel</code> class.</li> </ul>"},{"location":"development/contributing/#running-tests","title":"Running Tests","text":"<p>Running all tests is a part of running <code>just</code> or if you want to run only the tests instead of all checks you can run <code>just pytest</code>. For more advanced running please use <code>pytest</code> directly:</p> <pre><code>uv run pytest tests/{module}/ -v                    # Run all tests in a module\nuv run pytest tests/{module}/test_{function}.py -v  # Run specific test file\n</code></pre> <p>For more information on how to invoke pytest please refer to the How to invoke pytest documentation.</p>"},{"location":"development/contributing/#writing-tests","title":"Writing Tests","text":"<ul> <li>Any public API should have unit tests that reaffirm the documentation's description.</li> <li>If possible unit tests should use <code>@pytest.mark.parameterize</code> for generality and ease of adding new test cases.</li> <li>Use descriptive test names that explain what is being tested. In the case of testing exceptions also the type of exception.</li> <li>For smaller helper functions, especially internal helpers, doctests are sufficient.</li> </ul>"},{"location":"development/contributing/#type-checking","title":"Type Checking","text":"<p>All code must pass strict type checking with <code>mypy</code> which can be invoked with <code>just mypy</code>. Note that <code>ruff</code> will catch missing type hints whereas <code>mypy</code> will check that those type hints are correct and consistent.</p>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<p>We use MkDocs for documentation.</p>"},{"location":"development/contributing/#editing-documentation","title":"Editing Documentation","text":"<p>Documentation files are located in the <code>docs/</code> directory:</p> <pre><code>docs/\n|-- index.md                # Home page\n|-- guides/\n    |-- getting-started.md  # Getting started guide\n</code></pre> <p>The documentation structure is defined in <code>mkdocs.yml</code>.</p>"},{"location":"development/contributing/#viewing-documentation-locally","title":"Viewing Documentation Locally","text":"<p>To preview documentation changes locally you can run <code>just serve</code> which will build the documentation and start a local server at <code>http://127.0.0.1:8000/</code>. To only build the documentation you can run <code>just build</code> which will generate the documentation site in the <code>site/</code> directory.</p>"},{"location":"development/contributing/#documentation-testing","title":"Documentation Testing","text":"<p>In addition to unit tests and doctests, code contained in the documentation is also tested. This is ran as a part of <code>just</code>/<code>just pytest</code>. Each documentation page is treated as if it were one script so code blocks can reference previously created variables. To support this type of testing we use <code>Sybil</code>.</p>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"development/contributing/#before-submitting","title":"Before Submitting","text":"<ol> <li> <p>Run CI checks locally using <code>just ci</code>. This runs the same checks that CI will run:</p> </li> <li> <p><code>ruff format --check</code> - Verify code formatting (no auto-fix).</p> </li> <li><code>ruff check --no-fix</code> - Lint without modifications.</li> <li><code>pytest --doctest-modules</code> - Run test suite.</li> <li><code>mypy --strict</code> - Type checking.</li> </ol> <p>If you edit YAML files or the documentation please also run <code>just yamllint</code> or <code>just docs</code>, respectively. These tasks are separated from the <code>just ci</code> command but will also run as a CI check.</p> <ol> <li> <p>Update documentation if your changes affect user-facing functionality or add features that require usage guides.</p> </li> <li> <p>Add tests for new functionality or bug fixes. Particularly for bug fixes, the test should be written before the fix and fail without the fix present.</p> </li> </ol>"},{"location":"development/contributing/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<ol> <li> <p>Create a branch from <code>main</code> and make your changes on this branch using the code standards above. Please use clear and descriptive commit messages that explain the changes made and why. After your work is finished either push directly to <code>flepimop2</code> or your fork (depending on your permissions).</p> </li> <li> <p>Create a pull request with:</p> </li> <li> <p>The motivation for and a clear description of the changes.</p> </li> <li>Link any related issues (use \"Fixes #123\" to auto-close issues).</li> <li>Explicitly point out the relevant documentation changes.</li> </ol>"},{"location":"development/contributing/#pull-request-requirements","title":"Pull Request Requirements","text":"<ul> <li>PRs are tested against Python 3.11, 3.12, 3.13, and 3.14 using <code>just ci</code>.</li> <li>Documentation must build successfully with <code>just docs</code>.</li> <li>At least one maintainer approval is required before merging.</li> <li>Branches must be up to date against <code>main</code> before merging and have a linear history. Only rebases are allowed for merging.</li> </ul>"},{"location":"development/contributing/#reporting-issues","title":"Reporting Issues","text":""},{"location":"development/contributing/#bug-reports","title":"Bug Reports","text":"<p>When reporting bugs, please include:</p> <ul> <li>Operating system and version.</li> <li>Python version (e.g., Python 3.12.1).</li> <li><code>flepimop2</code> version as a git commit hash.</li> <li>A minimal, reproducible example that demonstrates the issue.</li> <li>An explanation of expected behavior vs actual behavior.</li> <li>Error messages or tracebacks if applicable.</li> </ul>"},{"location":"development/contributing/#feature-requests","title":"Feature Requests","text":"<p>For feature requests, please:</p> <ul> <li>Check existing issues to avoid duplicates.</li> <li>Clearly describe the use case and motivation.</li> <li>Provide examples of how the feature would be used.</li> <li>Be open to discussion about implementation approaches.</li> </ul>"},{"location":"development/contributing/#questions","title":"Questions","text":"<p>For questions about using flepimop2:</p> <ul> <li>Check the documentation (which can be viewed locally with <code>just serve</code> for now).</li> <li>Search existing issues for similar questions.</li> <li>Open a new issue with the \"question\" label.</li> </ul>"},{"location":"guides/getting-started/","title":"Getting Started","text":"<p>A brief tutorial on how to get started with <code>flepimop2</code>.</p> <pre><code>import math\nfoo = 2 * math.pi\n</code></pre> <p>And then</p> <pre><code>&gt;&gt;&gt; foo\n6.283185307179586\n</code></pre>"},{"location":"reference/cli/","title":"CLI","text":""},{"location":"reference/cli/#flepimop2","title":"flepimop2","text":"<p>flepimop2 - Flexible Epidemic Modeling Pipeline (version 2).</p> <p>Usage:</p> <pre><code>flepimop2 [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --version  Show the version and exit.\n  --help     Show this message and exit.\n</code></pre>"},{"location":"reference/cli/#flepimop2-build","title":"flepimop2 build","text":"<p>Compile and build a model defined in a configuration file.</p> <p>Usage:</p> <pre><code>flepimop2 build [OPTIONS] CONFIG\n</code></pre> <p>Options:</p> <pre><code>  --dry-run        Should this command be run using dry run?\n  -v, --verbosity  The verbosity level to use for this command.\n  --help           Show this message and exit.\n</code></pre>"},{"location":"reference/cli/#flepimop2-process","title":"flepimop2 process","text":"<p>Execute a processing step based on a configuration file.</p> <p>The <code>CONFIG</code> argument should point to a valid configuration file.</p> <p>Usage:</p> <pre><code>flepimop2 process [OPTIONS] CONFIG\n</code></pre> <p>Options:</p> <pre><code>  --dry-run          Should this command be run using dry run?\n  -t, --target TEXT  The target to use for this command.\n  -v, --verbosity    The verbosity level to use for this command.\n  --help             Show this message and exit.\n</code></pre>"},{"location":"reference/cli/#flepimop2-simulate","title":"flepimop2 simulate","text":"<p>Run simulations based on a configuration file.</p> <p>This command runs epidemic simulations specified from a provided configuration file. The <code>CONFIG</code> argument should point to a valid configuration file.</p> <p>Usage:</p> <pre><code>flepimop2 simulate [OPTIONS] CONFIG\n</code></pre> <p>Options:</p> <pre><code>  --dry-run          Should this command be run using dry run?\n  -t, --target TEXT  The target to use for this command.\n  -v, --verbosity    The verbosity level to use for this command.\n  --help             Show this message and exit.\n</code></pre>"},{"location":"reference/api/backend/","title":"Backend","text":""},{"location":"reference/api/backend/#flepimop2.backend","title":"<code>backend</code>","text":"<p>Backend module for handling file IO in flepimop2.</p>"},{"location":"reference/api/backend/#flepimop2.backend.BackendABC","title":"<code>BackendABC</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for flepimop2 file IO backends.</p>"},{"location":"reference/api/backend/#flepimop2.backend.BackendABC.read","title":"<code>read(run_meta)</code>","text":"<p>Read a numpy array from storage.</p> <p>Parameters:</p> Name Type Description Default <code>run_meta</code> <code>RunMeta</code> <p>Metadata about the current run.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The numpy array read from storage.</p> Source code in <code>src/flepimop2/backend/abc.py</code> <pre><code>def read(self, run_meta: RunMeta) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Read a numpy array from storage.\n\n    Args:\n        run_meta: Metadata about the current run.\n\n    Returns:\n        The numpy array read from storage.\n    \"\"\"\n    return self._read(run_meta)\n</code></pre>"},{"location":"reference/api/backend/#flepimop2.backend.BackendABC.save","title":"<code>save(data, run_meta)</code>","text":"<p>Save a numpy array to storage.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArray[float64]</code> <p>The numpy array to save.</p> required <code>run_meta</code> <code>RunMeta</code> <p>Metadata about the current run.</p> required Source code in <code>src/flepimop2/backend/abc.py</code> <pre><code>def save(self, data: NDArray[np.float64], run_meta: RunMeta) -&gt; None:\n    \"\"\"\n    Save a numpy array to storage.\n\n    Args:\n        data: The numpy array to save.\n        run_meta: Metadata about the current run.\n    \"\"\"\n    return self._save(data, run_meta)\n</code></pre>"},{"location":"reference/api/backend/#flepimop2.backend.build","title":"<code>build(config)</code>","text":"<p>Build a <code>BackendABC</code> from a configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | ModuleModel</code> <p>Configuration dictionary. The dict must contains a 'module' key, which will be used to lookup the Backend module path. The module will have \"flepimop2.backend.\" prepended.</p> required <p>Returns:</p> Type Description <code>BackendABC</code> <p>The constructed backend instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the built backend is not an instance of BackendABC.</p> Source code in <code>src/flepimop2/backend/abc.py</code> <pre><code>def build(config: dict[str, Any] | ModuleModel) -&gt; BackendABC:\n    \"\"\"Build a `BackendABC` from a configuration dictionary.\n\n    Args:\n        config: Configuration dictionary. The dict must contains a 'module' key, which\n            will be used to lookup the Backend module path. The module will have\n            \"flepimop2.backend.\" prepended.\n\n    Returns:\n        The constructed backend instance.\n\n    Raises:\n        TypeError: If the built backend is not an instance of BackendABC.\n    \"\"\"\n    config = config.model_dump() if isinstance(config, ModuleModel) else config\n    builder = _load_builder(f\"flepimop2.backend.{config.get('module', 'csv')}\")\n    backend = builder.build(config)\n    if not isinstance(backend, BackendABC):\n        msg = \"The built backend is not an instance of BackendABC.\"\n        raise TypeError(msg)\n    return backend\n</code></pre>"},{"location":"reference/api/backend/#flepimop2.backend.abc","title":"<code>abc</code>","text":"<p>Abstract base class for flepimop2 file IO backends.</p>"},{"location":"reference/api/backend/#flepimop2.backend.abc.BackendABC","title":"<code>BackendABC</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for flepimop2 file IO backends.</p>"},{"location":"reference/api/backend/#flepimop2.backend.abc.BackendABC.read","title":"<code>read(run_meta)</code>","text":"<p>Read a numpy array from storage.</p> <p>Parameters:</p> Name Type Description Default <code>run_meta</code> <code>RunMeta</code> <p>Metadata about the current run.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The numpy array read from storage.</p> Source code in <code>src/flepimop2/backend/abc.py</code> <pre><code>def read(self, run_meta: RunMeta) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Read a numpy array from storage.\n\n    Args:\n        run_meta: Metadata about the current run.\n\n    Returns:\n        The numpy array read from storage.\n    \"\"\"\n    return self._read(run_meta)\n</code></pre>"},{"location":"reference/api/backend/#flepimop2.backend.abc.BackendABC.save","title":"<code>save(data, run_meta)</code>","text":"<p>Save a numpy array to storage.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArray[float64]</code> <p>The numpy array to save.</p> required <code>run_meta</code> <code>RunMeta</code> <p>Metadata about the current run.</p> required Source code in <code>src/flepimop2/backend/abc.py</code> <pre><code>def save(self, data: NDArray[np.float64], run_meta: RunMeta) -&gt; None:\n    \"\"\"\n    Save a numpy array to storage.\n\n    Args:\n        data: The numpy array to save.\n        run_meta: Metadata about the current run.\n    \"\"\"\n    return self._save(data, run_meta)\n</code></pre>"},{"location":"reference/api/backend/#flepimop2.backend.abc.build","title":"<code>build(config)</code>","text":"<p>Build a <code>BackendABC</code> from a configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | ModuleModel</code> <p>Configuration dictionary. The dict must contains a 'module' key, which will be used to lookup the Backend module path. The module will have \"flepimop2.backend.\" prepended.</p> required <p>Returns:</p> Type Description <code>BackendABC</code> <p>The constructed backend instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the built backend is not an instance of BackendABC.</p> Source code in <code>src/flepimop2/backend/abc.py</code> <pre><code>def build(config: dict[str, Any] | ModuleModel) -&gt; BackendABC:\n    \"\"\"Build a `BackendABC` from a configuration dictionary.\n\n    Args:\n        config: Configuration dictionary. The dict must contains a 'module' key, which\n            will be used to lookup the Backend module path. The module will have\n            \"flepimop2.backend.\" prepended.\n\n    Returns:\n        The constructed backend instance.\n\n    Raises:\n        TypeError: If the built backend is not an instance of BackendABC.\n    \"\"\"\n    config = config.model_dump() if isinstance(config, ModuleModel) else config\n    builder = _load_builder(f\"flepimop2.backend.{config.get('module', 'csv')}\")\n    backend = builder.build(config)\n    if not isinstance(backend, BackendABC):\n        msg = \"The built backend is not an instance of BackendABC.\"\n        raise TypeError(msg)\n    return backend\n</code></pre>"},{"location":"reference/api/backend/#flepimop2.backend.csv","title":"<code>csv</code>","text":"<p>CSV backend for flepimop2.</p>"},{"location":"reference/api/backend/#flepimop2.backend.csv.CsvBackend","title":"<code>CsvBackend</code>","text":"<p>               Bases: <code>ModuleModel</code>, <code>BackendABC</code></p> <p>CSV backend for saving numpy arrays to CSV files.</p>"},{"location":"reference/api/backend/#flepimop2.backend.csv.build","title":"<code>build(config)</code>","text":"<p>Build a <code>CsvBackend</code> from a configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | ModuleModel</code> <p>Configuration dictionary or a <code>ModuleModel</code> to construct the CSV backend from.</p> required <p>Returns:</p> Type Description <code>CsvBackend</code> <p>The constructed csv backend.</p> Source code in <code>src/flepimop2/backend/csv.py</code> <pre><code>def build(config: dict[str, Any] | ModuleModel) -&gt; CsvBackend:\n    \"\"\"\n    Build a `CsvBackend` from a configuration dictionary.\n\n    Args:\n        config: Configuration dictionary or a `ModuleModel` to construct the CSV backend\n            from.\n\n    Returns:\n        The constructed csv backend.\n    \"\"\"\n    return CsvBackend.model_validate(\n        config.model_dump() if isinstance(config, ModuleModel) else config\n    )\n</code></pre>"},{"location":"reference/api/configuration/","title":"Configuration","text":""},{"location":"reference/api/configuration/#flepimop2.configuration","title":"<code>configuration</code>","text":"<p>Representations of parsed configuration files.</p>"},{"location":"reference/api/configuration/#flepimop2.configuration.ModuleGroupModel","title":"<code>ModuleGroupModel = Annotated[dict[str, ModuleModel], BeforeValidator(_to_default_dict)]</code>  <code>module-attribute</code>","text":"<p>Module group configuration model for flepimop2.</p>"},{"location":"reference/api/configuration/#flepimop2.configuration.ModuleTarget","title":"<code>ModuleTarget = Annotated[str, Field(min_length=1)]</code>  <code>module-attribute</code>","text":"<p>Module key type for flepimop2.</p>"},{"location":"reference/api/configuration/#flepimop2.configuration.ConfigurationModel","title":"<code>ConfigurationModel</code>","text":"<p>               Bases: <code>YamlSerializableBaseModel</code></p> <p>Configuration model for flepimop2.</p> <p>This model serves as the parent container for a parsed configuration file.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str | None</code> <p>An optional name for the configuration.</p> <code>engines</code> <code>ModuleGroupModel</code> <p>A dictionary of engine configurations.</p> <code>systems</code> <code>ModuleGroupModel</code> <p>A dictionary of system configurations.</p> <code>backends</code> <code>ModuleGroupModel</code> <p>A dictionary of backend configurations.</p> <code>process</code> <code>ModuleGroupModel</code> <p>A dictionary of process configurations.</p> <code>parameters</code> <code>dict[str, ParameterSpecificationModel]</code> <p>A dictionary of parameter configurations.</p> <code>simulate</code> <code>dict[str, SimulateSpecificationModel]</code> <p>A dictionary of simulation configurations.</p>"},{"location":"reference/api/configuration/#flepimop2.configuration.FixedParameterSpecificationModel","title":"<code>FixedParameterSpecificationModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fixed parameter specification model.</p> <p>This model represents a parameter with a fixed value.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>Literal['fixed']</code> <p>The type of the parameter specification, fixed to \"fixed\".</p> <code>value</code> <code>float</code> <p>The fixed numeric value of the parameter.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flepimop2.configuration import FixedParameterSpecificationModel\n&gt;&gt;&gt; param = FixedParameterSpecificationModel(value=12.34)\n&gt;&gt;&gt; param\nFixedParameterSpecificationModel(type='fixed', value=12.34)\n&gt;&gt;&gt; param.model_dump()\n12.34\n</code></pre>"},{"location":"reference/api/configuration/#flepimop2.configuration.ModuleModel","title":"<code>ModuleModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Module configuration model for flepimop2.</p> <p>Attributes:</p> Name Type Description <code>module</code> <code>str</code> <p>The type of the module.</p>"},{"location":"reference/api/configuration/#flepimop2.configuration.SimulateSpecificationModel","title":"<code>SimulateSpecificationModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for specifying a simulation for flepimop2.</p> <p>Attributes:</p> Name Type Description <code>engine</code> <code>ModuleTarget</code> <p>The name of the engine to use for the simulation.</p> <code>system</code> <code>ModuleTarget</code> <p>The name of the system to simulate.</p> <code>backend</code> <code>ModuleTarget</code> <p>The name of the backend to use for the simulation.</p> <code>times</code> <code>RangeSpec</code> <p>A list of time points at which to perform the simulation.</p> <code>params</code> <code>dict[str, float] | None</code> <p>Optional dictionary of parameters for the simulation.</p>"},{"location":"reference/api/configuration/#flepimop2.configuration.SimulateSpecificationModel.t_eval","title":"<code>t_eval</code>  <code>property</code>","text":"<p>Get the evaluation times as a NumPy array.</p> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>A NumPy array of evaluation times.</p>"},{"location":"reference/api/engine/","title":"Engine","text":""},{"location":"reference/api/engine/#flepimop2.engine","title":"<code>engine</code>","text":"<p>Abstract class for Engines to evolve Dynamic Systems.</p>"},{"location":"reference/api/engine/#flepimop2.engine.EngineABC","title":"<code>EngineABC(*args, **kwargs)</code>","text":"<p>Abstract class for Engines to evolve Dynamic Systems.</p> <p>Initialize the EngineABC.</p> <p>The default initialization sets the runner to a no-op function. Concrete implementations should override this with a valid runner function.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments.</p> <code>{}</code> Source code in <code>src/flepimop2/engine/abc.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ARG002\n    \"\"\"\n    Initialize the EngineABC.\n\n    The default initialization sets the runner to a no-op function. Concrete\n    implementations should override this with a valid runner function.\n\n    Args:\n        *args: Positional arguments.\n        **kwargs: Keyword arguments.\n    \"\"\"\n    self._runner = _no_run_func\n</code></pre>"},{"location":"reference/api/engine/#flepimop2.engine.EngineABC.run","title":"<code>run(system, eval_times, initial_state, params, **kwargs)</code>","text":"<p>Run the engine with the provided system and parameters.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>SystemABC</code> <p>The dynamic system to be evolved.</p> required <code>eval_times</code> <code>NDArray[float64]</code> <p>Array of time points for evaluation.</p> required <code>initial_state</code> <code>NDArray[float64]</code> <p>The initial state array.</p> required <code>params</code> <code>dict[str, Any]</code> <p>Additional parameters for the stepper.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the engine.</p> <code>{}</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The evolved time x state array.</p> Source code in <code>src/flepimop2/engine/abc.py</code> <pre><code>def run(\n    self,\n    system: SystemABC,\n    eval_times: NDArray[np.float64],\n    initial_state: NDArray[np.float64],\n    params: dict[str, Any],\n    **kwargs: Any,\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Run the engine with the provided system and parameters.\n\n    Args:\n        system: The dynamic system to be evolved.\n        eval_times: Array of time points for evaluation.\n        initial_state: The initial state array.\n        params: Additional parameters for the stepper.\n        **kwargs: Additional keyword arguments for the engine.\n\n    Returns:\n        The evolved time x state array.\n    \"\"\"\n    return self._runner(\n        system._stepper,  # noqa: SLF001\n        eval_times,\n        initial_state,\n        params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/api/engine/#flepimop2.engine.EngineProtocol","title":"<code>EngineProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Type-definition (Protocol) for engine runner functions.</p>"},{"location":"reference/api/engine/#flepimop2.engine.EngineProtocol.__call__","title":"<code>__call__(stepper, times, state, params, **kwargs)</code>","text":"<p>Protocol for engine runner functions.</p> <p>Parameters:</p> Name Type Description Default <code>stepper</code> <code>SystemProtocol</code> <p>The system stepper function.</p> required <code>times</code> <code>NDArray[float64]</code> <p>Array of time points.</p> required <code>state</code> <code>NDArray[float64]</code> <p>The current state array.</p> required <code>params</code> <code>dict[str, Any]</code> <p>Additional parameters for the stepper.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the engine.</p> <code>{}</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The evolved time x state array.</p> Source code in <code>src/flepimop2/engine/protocol.py</code> <pre><code>def __call__(\n    self,\n    stepper: SystemProtocol,\n    times: NDArray[np.float64],\n    state: NDArray[np.float64],\n    params: dict[str, Any],\n    **kwargs: Any,\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Protocol for engine runner functions.\n\n    Args:\n        stepper: The system stepper function.\n        times: Array of time points.\n        state: The current state array.\n        params: Additional parameters for the stepper.\n        **kwargs: Additional keyword arguments for the engine.\n\n    Returns:\n        The evolved time x state array.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/api/engine/#flepimop2.engine.build","title":"<code>build(config)</code>","text":"<p>Build a <code>EngineABC</code> from a configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | ModuleModel</code> <p>Configuration dictionary or a <code>ModuleModel</code> instance to construct the engine from.</p> required <p>Returns:</p> Type Description <code>EngineABC</code> <p>The constructed engine instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the built engine is not an instance of EngineABC.</p> Source code in <code>src/flepimop2/engine/abc.py</code> <pre><code>def build(config: dict[str, Any] | ModuleModel) -&gt; EngineABC:\n    \"\"\"Build a `EngineABC` from a configuration dictionary.\n\n    Args:\n        config: Configuration dictionary or a `ModuleModel` instance to construct the\n            engine from.\n\n    Returns:\n        The constructed engine instance.\n\n    Raises:\n        TypeError: If the built engine is not an instance of EngineABC.\n    \"\"\"\n    config = {\"module\": \"wrapper\"} | (\n        config.model_dump() if isinstance(config, ModuleModel) else config\n    )\n    builder = _load_builder(f\"flepimop2.engine.{config['module']}\")\n    engine = builder.build(config)\n    if not isinstance(engine, EngineABC):\n        msg = \"The built engine is not an instance of EngineABC.\"\n        raise TypeError(msg)\n    return engine\n</code></pre>"},{"location":"reference/api/engine/#flepimop2.engine.abc","title":"<code>abc</code>","text":"<p>Abstract class for Engines to evolve Dynamic Systems.</p>"},{"location":"reference/api/engine/#flepimop2.engine.abc.EngineABC","title":"<code>EngineABC(*args, **kwargs)</code>","text":"<p>Abstract class for Engines to evolve Dynamic Systems.</p> <p>Initialize the EngineABC.</p> <p>The default initialization sets the runner to a no-op function. Concrete implementations should override this with a valid runner function.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments.</p> <code>{}</code> Source code in <code>src/flepimop2/engine/abc.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ARG002\n    \"\"\"\n    Initialize the EngineABC.\n\n    The default initialization sets the runner to a no-op function. Concrete\n    implementations should override this with a valid runner function.\n\n    Args:\n        *args: Positional arguments.\n        **kwargs: Keyword arguments.\n    \"\"\"\n    self._runner = _no_run_func\n</code></pre>"},{"location":"reference/api/engine/#flepimop2.engine.abc.EngineABC.run","title":"<code>run(system, eval_times, initial_state, params, **kwargs)</code>","text":"<p>Run the engine with the provided system and parameters.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>SystemABC</code> <p>The dynamic system to be evolved.</p> required <code>eval_times</code> <code>NDArray[float64]</code> <p>Array of time points for evaluation.</p> required <code>initial_state</code> <code>NDArray[float64]</code> <p>The initial state array.</p> required <code>params</code> <code>dict[str, Any]</code> <p>Additional parameters for the stepper.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the engine.</p> <code>{}</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The evolved time x state array.</p> Source code in <code>src/flepimop2/engine/abc.py</code> <pre><code>def run(\n    self,\n    system: SystemABC,\n    eval_times: NDArray[np.float64],\n    initial_state: NDArray[np.float64],\n    params: dict[str, Any],\n    **kwargs: Any,\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Run the engine with the provided system and parameters.\n\n    Args:\n        system: The dynamic system to be evolved.\n        eval_times: Array of time points for evaluation.\n        initial_state: The initial state array.\n        params: Additional parameters for the stepper.\n        **kwargs: Additional keyword arguments for the engine.\n\n    Returns:\n        The evolved time x state array.\n    \"\"\"\n    return self._runner(\n        system._stepper,  # noqa: SLF001\n        eval_times,\n        initial_state,\n        params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/api/engine/#flepimop2.engine.abc.build","title":"<code>build(config)</code>","text":"<p>Build a <code>EngineABC</code> from a configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | ModuleModel</code> <p>Configuration dictionary or a <code>ModuleModel</code> instance to construct the engine from.</p> required <p>Returns:</p> Type Description <code>EngineABC</code> <p>The constructed engine instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the built engine is not an instance of EngineABC.</p> Source code in <code>src/flepimop2/engine/abc.py</code> <pre><code>def build(config: dict[str, Any] | ModuleModel) -&gt; EngineABC:\n    \"\"\"Build a `EngineABC` from a configuration dictionary.\n\n    Args:\n        config: Configuration dictionary or a `ModuleModel` instance to construct the\n            engine from.\n\n    Returns:\n        The constructed engine instance.\n\n    Raises:\n        TypeError: If the built engine is not an instance of EngineABC.\n    \"\"\"\n    config = {\"module\": \"wrapper\"} | (\n        config.model_dump() if isinstance(config, ModuleModel) else config\n    )\n    builder = _load_builder(f\"flepimop2.engine.{config['module']}\")\n    engine = builder.build(config)\n    if not isinstance(engine, EngineABC):\n        msg = \"The built engine is not an instance of EngineABC.\"\n        raise TypeError(msg)\n    return engine\n</code></pre>"},{"location":"reference/api/engine/#flepimop2.engine.protocol","title":"<code>protocol</code>","text":"<p>Type-definition (Protocol) for engine runner functions.</p>"},{"location":"reference/api/engine/#flepimop2.engine.protocol.EngineProtocol","title":"<code>EngineProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Type-definition (Protocol) for engine runner functions.</p>"},{"location":"reference/api/engine/#flepimop2.engine.protocol.EngineProtocol.__call__","title":"<code>__call__(stepper, times, state, params, **kwargs)</code>","text":"<p>Protocol for engine runner functions.</p> <p>Parameters:</p> Name Type Description Default <code>stepper</code> <code>SystemProtocol</code> <p>The system stepper function.</p> required <code>times</code> <code>NDArray[float64]</code> <p>Array of time points.</p> required <code>state</code> <code>NDArray[float64]</code> <p>The current state array.</p> required <code>params</code> <code>dict[str, Any]</code> <p>Additional parameters for the stepper.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the engine.</p> <code>{}</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The evolved time x state array.</p> Source code in <code>src/flepimop2/engine/protocol.py</code> <pre><code>def __call__(\n    self,\n    stepper: SystemProtocol,\n    times: NDArray[np.float64],\n    state: NDArray[np.float64],\n    params: dict[str, Any],\n    **kwargs: Any,\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Protocol for engine runner functions.\n\n    Args:\n        stepper: The system stepper function.\n        times: Array of time points.\n        state: The current state array.\n        params: Additional parameters for the stepper.\n        **kwargs: Additional keyword arguments for the engine.\n\n    Returns:\n        The evolved time x state array.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/api/engine/#flepimop2.engine.wrapper","title":"<code>wrapper</code>","text":"<p>A <code>EngineABC</code> which wraps a user-defined script file.</p>"},{"location":"reference/api/engine/#flepimop2.engine.wrapper.WrapperEngine","title":"<code>WrapperEngine(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModuleModel</code>, <code>EngineABC</code></p> <p>A <code>EngineABC</code> which wraps a user-defined script file.</p> Source code in <code>src/flepimop2/engine/abc.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ARG002\n    \"\"\"\n    Initialize the EngineABC.\n\n    The default initialization sets the runner to a no-op function. Concrete\n    implementations should override this with a valid runner function.\n\n    Args:\n        *args: Positional arguments.\n        **kwargs: Keyword arguments.\n    \"\"\"\n    self._runner = _no_run_func\n</code></pre>"},{"location":"reference/api/engine/#flepimop2.engine.wrapper.build","title":"<code>build(config)</code>","text":"<p>Build a <code>WrapperEngine</code> from a configuration arguments.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | ModuleModel</code> <p>Configuration dictionary or a <code>ModuleModel</code> instance to construct the wrapper engine from.</p> required <p>Returns:</p> Type Description <code>WrapperEngine</code> <p>The constructed wrapper engine instance.</p> Source code in <code>src/flepimop2/engine/wrapper.py</code> <pre><code>def build(config: dict[str, Any] | ModuleModel) -&gt; WrapperEngine:\n    \"\"\"\n    Build a `WrapperEngine` from a configuration arguments.\n\n    Args:\n        config: Configuration dictionary or a `ModuleModel` instance to construct the\n            wrapper engine from.\n\n    Returns:\n        The constructed wrapper engine instance.\n    \"\"\"\n    return WrapperEngine.model_validate(\n        config.model_dump() if isinstance(config, ModuleModel) else config\n    )\n</code></pre>"},{"location":"reference/api/logging/","title":"Logging","text":""},{"location":"reference/api/logging/#flepimop2.logging","title":"<code>logging</code>","text":"<p>Logging utilities for consistent script output.</p> <p>This module provides functionality for creating consistent outputs from CLI tools provided by this package.</p>"},{"location":"reference/api/logging/#flepimop2.logging.ClickHandler","title":"<code>ClickHandler(level=0, file=None, *, nl=True, err=False, color=None, punctuate=True)</code>","text":"<p>               Bases: <code>Handler</code></p> <p>Custom logging handler specifically for click based CLI tools.</p> <p>Initialize an instance of the click handler.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int | str</code> <p>The logging level to use for this handler.</p> <code>0</code> <code>file</code> <code>IO[Any] | None</code> <p>The file to write to. Defaults to stdout.</p> <code>None</code> <code>nl</code> <code>bool</code> <p>Print a newline after the message. Enabled by default.</p> <code>True</code> <code>err</code> <code>bool</code> <p>Write to stderr instead of stdout.</p> <code>False</code> <code>color</code> <code>bool | None</code> <p>Force showing or hiding colors and other styles. By default click will remove color if the output does not look like an interactive terminal.</p> <code>None</code> <code>punctuate</code> <code>bool</code> <p>A boolean indicating if punctuation should be added to the end of a log message provided if missing.</p> <code>True</code> Notes <p>For more details on the <code>file</code>, <code>nl</code>, <code>err</code>, and <code>color</code> args please refer to <code>click.echo</code>.</p> Source code in <code>src/flepimop2/logging.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    level: int | str = 0,\n    file: IO[Any] | None = None,\n    *,\n    nl: bool = True,\n    err: bool = False,\n    color: bool | None = None,\n    punctuate: bool = True,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of the click handler.\n\n    Args:\n        level: The logging level to use for this handler.\n        file: The file to write to. Defaults to stdout.\n        nl: Print a newline after the message. Enabled by default.\n        err: Write to stderr instead of stdout.\n        color: Force showing or hiding colors and other styles. By default click\n            will remove color if the output does not look like an interactive\n            terminal.\n        punctuate: A boolean indicating if punctuation should be added to the end\n            of a log message provided if missing.\n\n    Notes:\n        For more details on the `file`, `nl`, `err`, and `color` args please refer\n        to [`click.echo`](https://click.palletsprojects.com/en/8.1.x/api/#click.echo).\n    \"\"\"\n    super().__init__(level)\n    self._file = file\n    self._nl = nl\n    self._err = err\n    self._color = color\n    self._punctuate = punctuate\n</code></pre>"},{"location":"reference/api/logging/#flepimop2.logging.ClickHandler.emit","title":"<code>emit(record)</code>","text":"<p>Emit a given log record via <code>click.echo</code>.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The log record to output.</p> required See Also <p><code>logging.Handler.emit</code>.</p> Source code in <code>src/flepimop2/logging.py</code> <pre><code>def emit(self, record: logging.LogRecord) -&gt; None:\n    \"\"\"\n    Emit a given log record via `click.echo`.\n\n    Args:\n        record: The log record to output.\n\n    See Also:\n        [`logging.Handler.emit`](https://docs.python.org/3/library/logging.html#logging.Handler.emit).\n    \"\"\"\n    msg = self.format(record)\n    msg = f\"{msg}.\" if self._punctuate and not msg.endswith(_PUNCTUATION) else msg\n    click.echo(\n        message=msg, file=self._file, nl=self._nl, err=self._err, color=self._color\n    )\n</code></pre>"},{"location":"reference/api/logging/#flepimop2.logging.LoggingLevel","title":"<code>LoggingLevel</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>An enumeration of the logging levels used in this package.</p> <p>Attributes:</p> Name Type Description <code>DEBUG</code> <p>Detailed information, typically of interest only when diagnosing problems.</p> <code>INFO</code> <p>Confirmation that things are working as expected.</p> <code>WARNING</code> <p>An indication that something unexpected happened, or indicative of some problem in the near future (e.g., 'ode unstable'). The software is still working as expected.</p> <code>ERROR</code> <p>Due to a more serious problem, the software has not been able to perform some function.</p> <code>CRITICAL</code> <p>A serious error, indicating that the program itself may be unable to continue running.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flepimop2.logging import LoggingLevel\n&gt;&gt;&gt; LoggingLevel.DEBUG\n&lt;LoggingLevel.DEBUG: 10&gt;\n&gt;&gt;&gt; LoggingLevel.from_verbosity(2)\n&lt;LoggingLevel.INFO: 20&gt;\n&gt;&gt;&gt; LoggingLevel.from_verbosity(LoggingLevel.ERROR)\n&lt;LoggingLevel.ERROR: 40&gt;\n</code></pre>"},{"location":"reference/api/logging/#flepimop2.logging.LoggingLevel.from_verbosity","title":"<code>from_verbosity(verbosity)</code>  <code>classmethod</code>","text":"<p>Convert a verbosity level to a <code>LoggingLevel</code>.</p> <p>Parameters:</p> Name Type Description Default <code>verbosity</code> <code>int | LoggingLevel</code> <p>The verbosity level to convert.</p> required <p>Returns:</p> Type Description <code>LoggingLevel</code> <p>The corresponding <code>LoggingLevel</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>verbosity</code> is negative.</p> Source code in <code>src/flepimop2/logging.py</code> <pre><code>@classmethod\ndef from_verbosity(cls, verbosity: \"int | LoggingLevel\") -&gt; \"LoggingLevel\":\n    \"\"\"\n    Convert a verbosity level to a `LoggingLevel`.\n\n    Args:\n        verbosity: The verbosity level to convert.\n\n    Returns:\n        The corresponding `LoggingLevel`.\n\n    Raises:\n        ValueError: If `verbosity` is negative.\n    \"\"\"\n    if isinstance(verbosity, cls):\n        return verbosity\n    if verbosity &lt; 0:\n        msg = f\"`verbosity` must be non-negative, was given '{verbosity}'.\"\n        raise ValueError(msg)\n    if verbosity in set(cls):\n        return cls(verbosity)\n    return cls(_VERBOSITY_TO_LOGGING_LEVEL.get(verbosity, logging.DEBUG))\n</code></pre>"},{"location":"reference/api/logging/#flepimop2.logging.get_script_logger","title":"<code>get_script_logger(name, verbosity, handler=None, log_format=DEFAULT_LOG_FORMAT)</code>","text":"<p>Create a logger for use in scripts/CLI tools.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to display in the log message, useful for locating the source of logging messages. Almost always <code>__name__</code>.</p> required <code>verbosity</code> <code>int</code> <p>A non-negative integer for the verbosity level.</p> required <code>handler</code> <code>Handler | None</code> <p>An optional logging handler to use in creating the logger returned, or <code>None</code> to just use the <code>ClickHandler</code>.</p> <code>None</code> <code>log_format</code> <code>str</code> <p>The format to use for logged messages. Passed directly to the <code>fmt</code> argument of logging.Formatter.</p> <code>DEFAULT_LOG_FORMAT</code> <p>Returns:</p> Type Description <code>Logger</code> <p>An instance of <code>logging.Logger</code> that has the appropriate level set based on</p> <code>Logger</code> <p><code>verbosity</code> and a custom handler for outputting for CLI tools.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flepimop2.logging import get_script_logger\n&gt;&gt;&gt; logger = get_script_logger(__name__, 3)\n&gt;&gt;&gt; logger.info(\"This is a log info message\")\n2024-10-29 16:07:20,272:INFO&gt; This is a log info message.\n</code></pre> Source code in <code>src/flepimop2/logging.py</code> <pre><code>def get_script_logger(\n    name: str,\n    verbosity: int,\n    handler: logging.Handler | None = None,\n    log_format: str = DEFAULT_LOG_FORMAT,\n) -&gt; logging.Logger:\n    \"\"\"\n    Create a logger for use in scripts/CLI tools.\n\n    Args:\n        name: The name to display in the log message, useful for locating the source\n            of logging messages. Almost always `__name__`.\n        verbosity: A non-negative integer for the verbosity level.\n        handler: An optional logging handler to use in creating the logger returned, or\n            `None` to just use the `ClickHandler`.\n        log_format: The format to use for logged messages. Passed directly to the `fmt`\n            argument of [logging.Formatter](https://docs.python.org/3/library/logging.html#logging.Formatter).\n\n    Returns:\n        An instance of `logging.Logger` that has the appropriate level set based on\n        `verbosity` and a custom handler for outputting for CLI tools.\n\n    Examples:\n        &gt;&gt;&gt; from flepimop2.logging import get_script_logger\n        &gt;&gt;&gt; logger = get_script_logger(__name__, 3)\n        &gt;&gt;&gt; logger.info(\"This is a log info message\")  # doctest: +SKIP\n        2024-10-29 16:07:20,272:INFO&gt; This is a log info message.\n    \"\"\"\n    logger = logging.getLogger(name)\n    logger.setLevel(LoggingLevel.from_verbosity(verbosity))\n    handler = ClickHandler() if handler is None else handler\n    log_formatter = logging.Formatter(log_format)\n    for old_handler in logger.handlers:\n        logger.removeHandler(old_handler)\n    handler.setFormatter(log_formatter)\n    logger.addHandler(handler)\n    # pytest-dev/pytest#3697\n    logger.propagate = Path(sys.argv[0]).name == \"pytest\" if sys.argv else False\n    return logger\n</code></pre>"},{"location":"reference/api/meta/","title":"Meta","text":""},{"location":"reference/api/meta/#flepimop2.meta","title":"<code>meta</code>","text":"<p>Metadata types for flepimop2 runs.</p>"},{"location":"reference/api/meta/#flepimop2.meta.RunMeta","title":"<code>RunMeta</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Metadata for a flepimop2 run.</p> <p>Attributes:</p> Name Type Description <code>action</code> <code>Literal['simulate']</code> <p>The action performed in the run (e.g., \"simulate\").</p> <code>timestamp</code> <code>datetime</code> <p>The timestamp when the run was executed. Defaults to current UTC time.</p> <code>name</code> <code>str | None</code> <p>An optional name for the run, typically pulled from the config.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flepimop2.meta import RunMeta\n&gt;&gt;&gt; run_meta = RunMeta(name=\"test_run\")\n&gt;&gt;&gt; run_meta.action\n'simulate'\n&gt;&gt;&gt; run_meta.timestamp\ndatetime.datetime(..., tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt; run_meta.name\n'test_run'\n</code></pre>"},{"location":"reference/api/process/","title":"Process","text":""},{"location":"reference/api/process/#flepimop2.process","title":"<code>process</code>","text":"<p>Process module for handling processing steps in flepimop2.</p>"},{"location":"reference/api/process/#flepimop2.process.ProcessABC","title":"<code>ProcessABC</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for flepimop2 processing steps.</p>"},{"location":"reference/api/process/#flepimop2.process.ProcessABC.execute","title":"<code>execute(*, dry_run=False)</code>","text":"<p>Execute a processing step.</p> <p>Parameters:</p> Name Type Description Default <code>dry_run</code> <code>bool</code> <p>If True, the process will not actually execute but will simulate execution.</p> <code>False</code> Source code in <code>src/flepimop2/process/abc.py</code> <pre><code>def execute(self, *, dry_run: bool = False) -&gt; None:\n    \"\"\"\n    Execute a processing step.\n\n    Args:\n        dry_run: If True, the process will not actually execute but will simulate\n            execution.\n    \"\"\"\n    return self._process(dry_run=dry_run)\n</code></pre>"},{"location":"reference/api/process/#flepimop2.process.build","title":"<code>build(config)</code>","text":"<p>Build a <code>ProcessABC</code> from a configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | ModuleModel</code> <p>Configuration dictionary. The dict should contain a 'module' key, which will be used to lookup the Process module path. The module will have \"flepimop2.process.\" prepended.</p> required <p>Returns:</p> Name Type Description <code>ProcessABC</code> <code>ProcessABC</code> <p>The constructed process object.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the built process is not an instance of ProcessABC.</p> Source code in <code>src/flepimop2/process/abc.py</code> <pre><code>def build(config: dict[str, Any] | ModuleModel) -&gt; ProcessABC:\n    \"\"\"Build a `ProcessABC` from a configuration dictionary.\n\n    Args:\n        config: Configuration dictionary. The dict should contain a\n            'module' key, which will be used to lookup the Process module path.\n            The module will have \"flepimop2.process.\" prepended.\n\n    Returns:\n        ProcessABC: The constructed process object.\n\n    Raises:\n        TypeError: If the built process is not an instance of ProcessABC.\n    \"\"\"\n    config = {\"module\": \"shell\"} | (\n        config.model_dump() if isinstance(config, ModuleModel) else config\n    )\n    builder = _load_builder(f\"flepimop2.process.{config['module']}\")\n    process = builder.build(config)\n    if not isinstance(process, ProcessABC):\n        msg = \"The built process is not an instance of ProcessABC.\"\n        raise TypeError(msg)\n    return process\n</code></pre>"},{"location":"reference/api/process/#flepimop2.process.abc","title":"<code>abc</code>","text":"<p>Abstract base class for flepimop2 processing steps.</p>"},{"location":"reference/api/process/#flepimop2.process.abc.ProcessABC","title":"<code>ProcessABC</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for flepimop2 processing steps.</p>"},{"location":"reference/api/process/#flepimop2.process.abc.ProcessABC.execute","title":"<code>execute(*, dry_run=False)</code>","text":"<p>Execute a processing step.</p> <p>Parameters:</p> Name Type Description Default <code>dry_run</code> <code>bool</code> <p>If True, the process will not actually execute but will simulate execution.</p> <code>False</code> Source code in <code>src/flepimop2/process/abc.py</code> <pre><code>def execute(self, *, dry_run: bool = False) -&gt; None:\n    \"\"\"\n    Execute a processing step.\n\n    Args:\n        dry_run: If True, the process will not actually execute but will simulate\n            execution.\n    \"\"\"\n    return self._process(dry_run=dry_run)\n</code></pre>"},{"location":"reference/api/process/#flepimop2.process.abc.build","title":"<code>build(config)</code>","text":"<p>Build a <code>ProcessABC</code> from a configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | ModuleModel</code> <p>Configuration dictionary. The dict should contain a 'module' key, which will be used to lookup the Process module path. The module will have \"flepimop2.process.\" prepended.</p> required <p>Returns:</p> Name Type Description <code>ProcessABC</code> <code>ProcessABC</code> <p>The constructed process object.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the built process is not an instance of ProcessABC.</p> Source code in <code>src/flepimop2/process/abc.py</code> <pre><code>def build(config: dict[str, Any] | ModuleModel) -&gt; ProcessABC:\n    \"\"\"Build a `ProcessABC` from a configuration dictionary.\n\n    Args:\n        config: Configuration dictionary. The dict should contain a\n            'module' key, which will be used to lookup the Process module path.\n            The module will have \"flepimop2.process.\" prepended.\n\n    Returns:\n        ProcessABC: The constructed process object.\n\n    Raises:\n        TypeError: If the built process is not an instance of ProcessABC.\n    \"\"\"\n    config = {\"module\": \"shell\"} | (\n        config.model_dump() if isinstance(config, ModuleModel) else config\n    )\n    builder = _load_builder(f\"flepimop2.process.{config['module']}\")\n    process = builder.build(config)\n    if not isinstance(process, ProcessABC):\n        msg = \"The built process is not an instance of ProcessABC.\"\n        raise TypeError(msg)\n    return process\n</code></pre>"},{"location":"reference/api/process/#flepimop2.process.shell","title":"<code>shell</code>","text":"<p>Shell process for flepimop2.</p>"},{"location":"reference/api/process/#flepimop2.process.shell.ShellProcess","title":"<code>ShellProcess</code>","text":"<p>               Bases: <code>ModuleModel</code>, <code>ProcessABC</code></p> <p>Shell process for executing commands.</p> <p>Attributes:</p> Name Type Description <code>module</code> <code>Literal['shell']</code> <p>The module type, fixed to \"shell\".</p> <code>command</code> <code>str</code> <p>The shell command to execute.</p> <code>args</code> <code>list[str]</code> <p>Arguments to pass to the shell command.</p>"},{"location":"reference/api/process/#flepimop2.process.shell.build","title":"<code>build(config)</code>","text":"<p>Build a <code>ShellProcess</code> from a configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | ModuleModel</code> <p>Configuration dictionary to create a shell process. If module key is defined, it must be \"shell\". Must contain a 'command' key with the shell command to execute.</p> required <p>Returns:</p> Type Description <code>ShellProcess</code> <p>The ready-to-use <code>ShellProcess</code> instance.</p> Source code in <code>src/flepimop2/process/shell.py</code> <pre><code>def build(config: dict[str, Any] | ModuleModel) -&gt; ShellProcess:\n    \"\"\"\n    Build a [`ShellProcess`][flepimop2.process.shell.ShellProcess] from a configuration.\n\n    Args:\n        config: Configuration dictionary to create a shell process. If module key is\n            defined, it must be \"shell\". Must contain a 'command' key with the shell\n            command to execute.\n\n    Returns:\n        The ready-to-use [`ShellProcess`][flepimop2.process.shell.ShellProcess]\n            instance.\n    \"\"\"\n    return ShellProcess.model_validate(\n        config.model_dump() if isinstance(config, ModuleModel) else config\n    )\n</code></pre>"},{"location":"reference/api/system/","title":"System","text":""},{"location":"reference/api/system/#flepimop2.system","title":"<code>system</code>","text":"<p>Abstract class for Dynamic Systems.</p>"},{"location":"reference/api/system/#flepimop2.system.SystemABC","title":"<code>SystemABC(*args, **kwargs)</code>","text":"<p>Abstract class for Dynamic Systems.</p> <p>Initialize the SystemABC.</p> <p>The default initialization sets the stepper to a no-op function. Concrete implementations should override this with a valid stepper function.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments.</p> <code>{}</code> Source code in <code>src/flepimop2/system/abc.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ARG002\n    \"\"\"\n    Initialize the SystemABC.\n\n    The default initialization sets the stepper to a no-op function. Concrete\n    implementations should override this with a valid stepper function.\n\n    Args:\n        *args: Positional arguments.\n        **kwargs: Keyword arguments.\n    \"\"\"\n    self._stepper = _no_step_function\n</code></pre>"},{"location":"reference/api/system/#flepimop2.system.SystemABC.step","title":"<code>step(time, state, **params)</code>","text":"<p>Perform a single step of the system's dynamics.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float64</code> <p>The current time.</p> required <code>state</code> <code>NDArray[float64]</code> <p>The current state array.</p> required <code>**params</code> <code>Any</code> <p>Additional parameters for the stepper.</p> <code>{}</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The next state array after one step.</p> Source code in <code>src/flepimop2/system/abc.py</code> <pre><code>def step(\n    self, time: np.float64, state: NDArray[np.float64], **params: Any\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Perform a single step of the system's dynamics.\n\n    Args:\n        time: The current time.\n        state: The current state array.\n        **params: Additional parameters for the stepper.\n\n    Returns:\n        The next state array after one step.\n    \"\"\"\n    return self._stepper(time, state, **params)\n</code></pre>"},{"location":"reference/api/system/#flepimop2.system.SystemProtocol","title":"<code>SystemProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Type-definition (Protocol) for system stepper functions.</p>"},{"location":"reference/api/system/#flepimop2.system.SystemProtocol.__call__","title":"<code>__call__(time, state, **kwargs)</code>","text":"<p>Protocol for system stepper functions.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float64</code> <p>The current time.</p> required <code>state</code> <code>NDArray[float64]</code> <p>The current state array.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the stepper.</p> <code>{}</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The next state array after one step.</p> Source code in <code>src/flepimop2/system/protocol.py</code> <pre><code>def __call__(\n    self, time: np.float64, state: NDArray[np.float64], **kwargs: Any\n) -&gt; NDArray[np.float64]:\n    \"\"\"Protocol for system stepper functions.\n\n    Args:\n        time: The current time.\n        state: The current state array.\n        **kwargs: Additional keyword arguments for the stepper.\n\n    Returns:\n        The next state array after one step.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/api/system/#flepimop2.system.build","title":"<code>build(config)</code>","text":"<p>Build a <code>SystemABC</code> from a configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | ModuleModel</code> <p>Configuration dictionary or a <code>ModuleModel</code> instance.</p> required <p>Returns:</p> Type Description <code>SystemABC</code> <p>The constructed system instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the built system is not an instance of SystemABC.</p> Source code in <code>src/flepimop2/system/abc.py</code> <pre><code>def build(config: dict[str, Any] | ModuleModel) -&gt; SystemABC:\n    \"\"\"\n    Build a `SystemABC` from a configuration dictionary.\n\n    Args:\n        config: Configuration dictionary or a `ModuleModel` instance.\n\n    Returns:\n        The constructed system instance.\n\n    Raises:\n        TypeError: If the built system is not an instance of SystemABC.\n    \"\"\"\n    config = {\"module\": \"wrapper\"} | (\n        config.model_dump() if isinstance(config, ModuleModel) else config\n    )\n    builder = _load_builder(f\"flepimop2.system.{config['module']}\")\n    system = builder.build(config)\n    if not isinstance(system, SystemABC):\n        msg = \"The built system is not an instance of SystemABC.\"\n        raise TypeError(msg)\n    return system\n</code></pre>"},{"location":"reference/api/system/#flepimop2.system.abc","title":"<code>abc</code>","text":"<p>Abstract class for Dynamic Systems.</p>"},{"location":"reference/api/system/#flepimop2.system.abc.SystemABC","title":"<code>SystemABC(*args, **kwargs)</code>","text":"<p>Abstract class for Dynamic Systems.</p> <p>Initialize the SystemABC.</p> <p>The default initialization sets the stepper to a no-op function. Concrete implementations should override this with a valid stepper function.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments.</p> <code>{}</code> Source code in <code>src/flepimop2/system/abc.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ARG002\n    \"\"\"\n    Initialize the SystemABC.\n\n    The default initialization sets the stepper to a no-op function. Concrete\n    implementations should override this with a valid stepper function.\n\n    Args:\n        *args: Positional arguments.\n        **kwargs: Keyword arguments.\n    \"\"\"\n    self._stepper = _no_step_function\n</code></pre>"},{"location":"reference/api/system/#flepimop2.system.abc.SystemABC.step","title":"<code>step(time, state, **params)</code>","text":"<p>Perform a single step of the system's dynamics.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float64</code> <p>The current time.</p> required <code>state</code> <code>NDArray[float64]</code> <p>The current state array.</p> required <code>**params</code> <code>Any</code> <p>Additional parameters for the stepper.</p> <code>{}</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The next state array after one step.</p> Source code in <code>src/flepimop2/system/abc.py</code> <pre><code>def step(\n    self, time: np.float64, state: NDArray[np.float64], **params: Any\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Perform a single step of the system's dynamics.\n\n    Args:\n        time: The current time.\n        state: The current state array.\n        **params: Additional parameters for the stepper.\n\n    Returns:\n        The next state array after one step.\n    \"\"\"\n    return self._stepper(time, state, **params)\n</code></pre>"},{"location":"reference/api/system/#flepimop2.system.abc.build","title":"<code>build(config)</code>","text":"<p>Build a <code>SystemABC</code> from a configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | ModuleModel</code> <p>Configuration dictionary or a <code>ModuleModel</code> instance.</p> required <p>Returns:</p> Type Description <code>SystemABC</code> <p>The constructed system instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the built system is not an instance of SystemABC.</p> Source code in <code>src/flepimop2/system/abc.py</code> <pre><code>def build(config: dict[str, Any] | ModuleModel) -&gt; SystemABC:\n    \"\"\"\n    Build a `SystemABC` from a configuration dictionary.\n\n    Args:\n        config: Configuration dictionary or a `ModuleModel` instance.\n\n    Returns:\n        The constructed system instance.\n\n    Raises:\n        TypeError: If the built system is not an instance of SystemABC.\n    \"\"\"\n    config = {\"module\": \"wrapper\"} | (\n        config.model_dump() if isinstance(config, ModuleModel) else config\n    )\n    builder = _load_builder(f\"flepimop2.system.{config['module']}\")\n    system = builder.build(config)\n    if not isinstance(system, SystemABC):\n        msg = \"The built system is not an instance of SystemABC.\"\n        raise TypeError(msg)\n    return system\n</code></pre>"},{"location":"reference/api/system/#flepimop2.system.protocol","title":"<code>protocol</code>","text":"<p>Type-definition (Protocol) for system stepper functions.</p>"},{"location":"reference/api/system/#flepimop2.system.protocol.SystemProtocol","title":"<code>SystemProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Type-definition (Protocol) for system stepper functions.</p>"},{"location":"reference/api/system/#flepimop2.system.protocol.SystemProtocol.__call__","title":"<code>__call__(time, state, **kwargs)</code>","text":"<p>Protocol for system stepper functions.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float64</code> <p>The current time.</p> required <code>state</code> <code>NDArray[float64]</code> <p>The current state array.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the stepper.</p> <code>{}</code> <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>The next state array after one step.</p> Source code in <code>src/flepimop2/system/protocol.py</code> <pre><code>def __call__(\n    self, time: np.float64, state: NDArray[np.float64], **kwargs: Any\n) -&gt; NDArray[np.float64]:\n    \"\"\"Protocol for system stepper functions.\n\n    Args:\n        time: The current time.\n        state: The current state array.\n        **kwargs: Additional keyword arguments for the stepper.\n\n    Returns:\n        The next state array after one step.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/api/system/#flepimop2.system.wrapper","title":"<code>wrapper</code>","text":"<p>A <code>SystemABC</code> which wraps a user-defined script file.</p>"},{"location":"reference/api/system/#flepimop2.system.wrapper.WrapperSystem","title":"<code>WrapperSystem(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModuleModel</code>, <code>SystemABC</code></p> <p>A <code>SystemABC</code> which wraps a user-defined script file.</p> Source code in <code>src/flepimop2/system/abc.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ARG002\n    \"\"\"\n    Initialize the SystemABC.\n\n    The default initialization sets the stepper to a no-op function. Concrete\n    implementations should override this with a valid stepper function.\n\n    Args:\n        *args: Positional arguments.\n        **kwargs: Keyword arguments.\n    \"\"\"\n    self._stepper = _no_step_function\n</code></pre>"},{"location":"reference/api/system/#flepimop2.system.wrapper.build","title":"<code>build(config)</code>","text":"<p>Build a <code>WrapperSystem</code> from a configuration arguments.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | ModuleModel</code> <p>Configuration dictionary or a <code>ModuleModel</code> instance.</p> required <p>Returns:</p> Type Description <code>WrapperSystem</code> <p>The constructed wrapper system instance.</p> Source code in <code>src/flepimop2/system/wrapper.py</code> <pre><code>def build(config: dict[str, Any] | ModuleModel) -&gt; WrapperSystem:\n    \"\"\"\n    Build a `WrapperSystem` from a configuration arguments.\n\n    Args:\n        config: Configuration dictionary or a `ModuleModel` instance.\n\n    Returns:\n        The constructed wrapper system instance.\n    \"\"\"\n    return WrapperSystem.model_validate(\n        config.model_dump() if isinstance(config, ModuleModel) else config\n    )\n</code></pre>"}]}