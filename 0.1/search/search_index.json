{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to <code>flepimop2</code>","text":"<p>The next generation of the flexible epidemic modeling pipeline.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<p>You'll need git and pipx on your system.</p> <pre><code>git clone git@github.com:ACCIDDA/flepimop2.git\ncd flepimop2\npipx install .\n</code></pre> <p>This clones the source of the library, then uses it to install the application.</p>"},{"location":"#create-a-project","title":"Create a Project","text":"<p>Somewhere else on your system, run the command</p> <pre><code>flepimop2 skeleton quick_start_project -v\ncd quick_start_project\n</code></pre> <p>This will create a new directory, <code>quick_start_project</code> and populate that directory with some files. The <code>-v</code> flag (for \"verbose\") will cause <code>skeleton</code> to also display the created directory structure.</p> <p>The most basic skeleton does not provide a system or engine: you will need to specify those. Here is an example SIR system and an example ODE engine:</p> Basic SIR Model <pre><code>\"\"\"SIR model plugin for flepimop2 demo.\"\"\"\n\nimport numpy as np\n\nfrom flepimop2.typing import Float64NDArray\n\n\ndef stepper(\n    t: float,  # noqa: ARG001\n    y: Float64NDArray,\n    beta: float,\n    gamma: float,\n) -&gt; Float64NDArray:\n    \"\"\"\n    Compute dY/dt for the SIR model.\n\n    Args:\n        t: The current time (not used in this model, but included for compatibility).\n        y: A numpy array containing the current values [S, I, R].\n        beta: The infection rate.\n        gamma: The recovery rate.\n\n    Returns:\n        A numpy array containing the derivatives [dS/dt, dI/dt, dR/dt].\n\n    \"\"\"\n    y_s, y_i, _ = np.asarray(y, dtype=float)\n    infection = (beta * y_s * y_i) / np.sum(y)\n    recovery = gamma * y_i\n    dydt = [-infection, infection - recovery, recovery]\n    return np.array(dydt, dtype=float)\n</code></pre> Basic scipy ODE Solver Engine <pre><code>\"\"\"ODE solver plugin that wraps `scipy.integrate.solve_ivp` for flepimop2 demo.\"\"\"\n\nfrom typing import Any\n\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\nfrom flepimop2.system.abc import SystemProtocol\nfrom flepimop2.typing import Float64NDArray\n\n\ndef runner(\n    fun: SystemProtocol,\n    times: Float64NDArray,\n    y0: Float64NDArray,\n    params: dict[str, Any] | None = None,\n    **solver_options: Any,\n) -&gt; Float64NDArray:\n    \"\"\"Solve an initial value problem using scipy.solve_ivp.\n\n    Args:\n        fun (SystemProtocol): A function that computes derivatives.\n        times (Float64NDArray): sequence of time points where we evaluate the\n          solution. Must have length &gt;= 1.\n        y0 (Float64NDArray): Initial condition.\n        params: Optional dict of keyword parameters forwarded to fun.\n        **solver_options: Additional keyword options forwarded to\n          scipy.integrate.solve_ivp.\n\n    Returns:\n        FloatArray: Array with time and state values evaluated at `times`.\n        Each row is [t, y...].\n\n    Raises:\n        ValueError: If `times` is not a 1D sequence of time points with length &gt;= 1, or\n            if the first time point is negative.\n\n    \"\"\"\n    if not (times.ndim == 1 and times.size &gt;= 1):\n        msg = \"times must be a 1D sequence of time points\"\n        raise ValueError(msg)\n\n    times.sort()\n\n    t0, tf = 0.0, times[-1]\n    if times[0] &lt; t0:\n        msg = f\"times[0] must be &gt;= 0; got times[0]={times[0]}\"\n        raise ValueError(msg)\n\n    args = tuple(val for val in params.values()) if params is not None else None\n    result = solve_ivp(\n        fun,\n        (t0, tf),\n        y0,\n        t_eval=times,\n        args=args,  # type: ignore[arg-type]\n        **solver_options,\n    )\n    return np.transpose(np.vstack((result.t, result.y)))\n</code></pre> <p>You'll also need to update the skeleton configuration file with these additions and set some parameters:</p> <pre><code>system:\n  - module: wrapper\n    script: model_input/plugins/SIR.py\n\nengine:\n  - module: wrapper\n    script: model_input/plugins/solve_ivp.py\n\nparameter:\n  beta:\n    module: fixed\n    value: 0.3\n  gamma:\n    module: fixed\n    value: 0.1\n  s0:\n    module: fixed\n    value: 999\n  i0:\n    module: fixed\n    value: 1\n  r0:\n    module: fixed\n    value: 0\n</code></pre>"},{"location":"#simulate-an-outbreak","title":"Simulate an Outbreak","text":"<p>Within the <code>quick_start_project</code> folder, you can now use <code>flepimop2</code> to run your model:</p> <pre><code>flepimop2 simulate configs/config.yaml\n</code></pre>"},{"location":"#what-is-flepimop","title":"What is <code>flepimop</code>?","text":"<p>The <code>flepimop</code> python package is a combined command line interface and library. The CLI application works with user commands and configuration files to execute analysis pipelines. Because <code>flepimop</code> is also a library, users can write their own flexible analyses leveraging that library to read and write data (and configuration information) in a way that \"just works\" with the pipeline. Additionally, advanced users can develop their own shareable modules that work with the pipeline.</p> <p>illustration of analysis flow illustration of how elements fit together</p>"},{"location":"#work-with-us","title":"Work with Us!","text":"<p>To contribute to the main <code>flepimop2</code> pipeline, you can join us on github.</p> <p>contact info, invitation to collaborate / contribute to repo</p>"},{"location":"#site-development","title":"Site Development","text":"<p>This site uses Material for MkDocs, which is a theme for MkDocs.</p> <p>To launch the site in developer mode, navigate to the <code>flepimop2</code> repo and then invoke at the command prompt:</p> <pre><code>just serve\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Initialized <code>flepimop2</code>.</li> <li>Added documentation using <code>mkdocs</code> that includes API/CLI reference as well as reusing <code>CHANGELOG.md</code> and <code>CONTRIBUTING.md</code> where appropriate.</li> <li>Added basic configuration models to parse and serialize configuration files. These are contained in the <code>flepimop2.configuration</code> module.</li> <li>Added core simulation infrastructure including engines (machinery to evolve a model) and systems (descriptions of model changes). These are contained in the <code>flepimop2.engine/system/backend</code> modules.</li> <li>Added the ability to execute auxiliary commands in the context of <code>flepimop2</code> with the <code>flepimop2 process</code> CLI backed by the <code>flepimop.process</code> module.</li> <li>Converted <code>flepimop2</code> to a PEP420 implicit namespace package so external providers can inject themselves into the <code>flepimop2</code> namespace. This allows users to reference modules by name only and then <code>flepimop2</code> will resolve the kind of module based on its location in a configuration file. See #45.</li> <li>Added <code>flepimop2.abcs</code> as a convenient re-export of ABCs/protocols for developer use. See #85.</li> <li>Made parameters modular, similar to backends/engines/processes/systems, to allow external packages to provide their own parameter types. See #75.</li> <li>Restricted the name of user defined backends/engines/parameters/processes/systems to comply with the custom <code>IdentifierString</code> type.</li> <li>Added a new <code>flepimop2 skeleton</code> CLI command for scaffolding a project repository. See #84.</li> <li>Added <code>flepimop.testing</code> with functionality for integration testing, both for <code>flepimop2</code> itself and for external provider packages. See #107.</li> <li>Added a parent class, <code>ModuleABC</code>, for all customizable modules that sets a required <code>module</code> attribute and provides infrastructure for non-standardized properties information. Also extended said infrastructure to allow for standardized property information for <code>SystemABC</code>. See #113, #126, #129.</li> </ul>"},{"location":"development/adding-a-new-cli-command/","title":"Adding A New CLI Command","text":""},{"location":"development/adding-a-new-cli-command/#adding-a-new-cli-command","title":"Adding A New CLI Command","text":"<p>This tutorial will show how to:</p> <ul> <li>Add a new command to the <code>flepimop2</code> CLI.</li> <li>Add a new option to <code>flepimop2</code>'s CLI infrastructure.</li> <li>Test the newly added command.</li> </ul> <p>In this tutorial will demonstrate adding a new command called <code>flepimop2 hello</code> which will print hello world a user specified number of times.</p>"},{"location":"development/adding-a-new-cli-command/#brief-overview-of-flepimop2s-cli-infrastructure","title":"Brief Overview Of <code>flepimop2</code>'s CLI Infrastructure","text":"<p><code>flepimop2</code>'s CLI infrastructure might be a bit heavier and stricter than previous CLI programs a developer has worked with. The reason for this is to enforce consistency for the inputs and outputs of CLI commands. The primary restrictions of this approach are:</p> <ul> <li>CLI commands must implement a common abstract base class which provides a common framework for command implementations.</li> <li>Options/arguments are shared among all CLI commands so they have the same meaning and usage across commands. Developers cannot add bespoke options/arguments for their command.</li> <li>CLI outputs are made consistent via a common logging infrastructure so the outputs of commands have a common feel across the <code>flepimop2</code> CLI.</li> </ul> <p><code>flepimop2</code>'s CLI infrastructure is contained in the private <code>flepimop2._cli</code> subpackage. The most important elements of this subpackage are:</p> <ul> <li><code>CliCommand</code>: The abstract base class that CLI commands must implement. The main benefit of having CLI commands subclass a common class is that repeated logic can be consolidated, CLI inputs/outputs can be made consistent, and development work can be eased.</li> <li><code>COMMON_OPTIONS</code>: A constant dictionary mapping option/argument names to their definitions. CLI commands can request options/arguments from this dictionary by having them as keyword only arguments to their <code>run</code> method. The main benefit of this approach is that commands cannot define bespoke options/arguments and developers are forced to use consistent meanings across commands. I.e. the <code>--dry-run</code> option means the same thing in all commands.</li> <li><code>register_command</code>: The function that attaches a user's implementation of <code>CliCommand</code> to the <code>flepimop2</code> CLI.</li> </ul> <p>This infrastructure utilizes <code>click</code> so it may be helpful to reference their documentation occasionally. </p>"},{"location":"development/adding-a-new-cli-command/#adding-the-flepimop2-hello-command","title":"Adding The <code>flepimop2 hello</code> Command","text":"<p>In particular this tutorial will be add a new command to the <code>flepimop2</code> CLI called <code>hello</code> which will take a new number argument. The end result of this tutorial will be:</p> <pre><code>$ flepimop2 --help\nUsage: flepimop2 [OPTIONS] COMMAND [ARGS]...\n\n  flepimop2 - Flexible Epidemic Modeling Pipeline (version 2).\n\nOptions:\n  --version  Show the version and exit.\n  --help     Show this message and exit.\n\nCommands:\n  build     Compile and build a model defined in a configuration file.\n  hello     This command says hello a specified number of times.\n  process   Execute a processing step based on a configuration file.\n  simulate  Run simulations based on a configuration file.\n$ flepimop2 hello --help\nUsage: flepimop2 hello [OPTIONS] [TIMES]\n\n  This command says hello a specified number of times.\n\nOptions:\n  --dry-run        Should this command be run using dry run?\n  -v, --verbosity  The verbosity level to use for this command.\n  --help           Show this message and exit.\n</code></pre>"},{"location":"development/adding-a-new-cli-command/#add-the-hellocommand-class","title":"Add The <code>HelloCommand</code> Class","text":"<p>The first step is to implement the <code>HelloCommand</code> class in a new <code>src/flepimop2/_cli/_hello_command.py</code> file.</p> <pre><code>\"\"\"Hello command implementation.\"\"\"\n\n__all__ = []\n\n\nfrom flepimop2._cli._cli_command import CliCommand\n\n\nclass HelloCommand(CliCommand):\n    \"\"\"This command says hello a specified number of times.\"\"\"\n\n    def run(self, *, times: int, dry_run: bool) -&gt; None:  # type: ignore[override]\n        \"\"\"\n        Say hello a specified number of times.\n\n        Args:\n            times: The number of times to say hello.\n            dry_run: Whether dry run mode is enabled.\n        \"\"\"\n        if dry_run:\n            self.info(f\"Would said hello {times} time(s).\")\n            return\n        for i in range(times):\n            self.info(f\"({i + 1}/{times}) Hello, world!\")\n</code></pre> <p>The <code>run</code> method contains the logic of the command and it's keyword arguments correspond to the options/arguments requested from <code>COMMON_OPTIONS</code>. The <code>CliCommand</code> also provides consistent logging infrastructure in the form of the <code>log</code>, <code>debug</code>, <code>info</code>, <code>warning</code>, <code>error</code>, and <code>critical</code> methods. Note that a <code>verbosity</code> option is not explicitly requested, this option is added by default to the command and <code>CliCommand</code> handles translating the given verbosity to a logging level so developers only need to concern themselves with calling the appropriate logging method. To ease development the class docstring will be used as the help string for the command and the command's name is extracted from the class name.</p>"},{"location":"development/adding-a-new-cli-command/#adding-a-new-option","title":"Adding A New Option","text":"<p>The implementation of <code>flepimop2 hello</code> needs a times argument. To add this argument a developer needs to add it to the <code>COMMON_OPTIONS</code> dictionary in <code>src/flepimop2/_cli/_options.py</code>.</p> <pre><code># Dictionary of common Click options and arguments\n# These can be requested by command classes to maintain consistency\nCOMMON_OPTIONS: Final = {\n    ...\n    \"times\": click.argument(\n        \"times\",\n        type=click.IntRange(min=1),\n        default=1,\n        required=False,\n    ),\n    ...\n}\n</code></pre> <p>This adds a new <code>times</code> argument to the <code>COMMON_OPTIONS</code> dictionary. Note that the argument is not tied specifically to the <code>flepimop2 hello</code> command since this argument could be used by other commands.</p>"},{"location":"development/adding-a-new-cli-command/#register-the-new-command","title":"Register The New Command","text":"<p>The final step is to register the new command with the <code>flepimop2</code> CLI by adding a call to <code>register_command</code> in <code>src/flepimop2/_cli/_cli.py</code>.</p> <pre><code>...\nfrom flepimop2._cli._build_command import BuildCommand\nfrom flepimop2._cli._hello_command import HelloCommand\nfrom flepimop2._cli._process_command import ProcessCommand\n...\n# Register all commands\nregister_command(BuildCommand, cli)\nregister_command(SimulateCommand, cli)\nregister_command(ProcessCommand, cli)\nregister_command(HelloCommand, cli)\n</code></pre> <p>The <code>register_command</code> function takes the CLI command class as it's first argument and the <code>click.Group</code> to attach the command to. In this case the command is being attached to the main cli, <code>cli</code>, so it can be invoked <code>flepimop2 hello</code>. But one could have created a new click group so one could have nested subcommands, i.e. <code>flepimop2 greetings hello</code>.</p>"},{"location":"development/adding-a-new-cli-command/#testing-a-new-command","title":"Testing A New Command","text":"<p>Before preparing this command for a PR it's important to test the new command. There are two types of testing:</p> <ol> <li>Ad-hoc testing: Testing the command manually for expected behavior.</li> <li>Unit testing: Programmatically testing the command.</li> </ol>"},{"location":"development/adding-a-new-cli-command/#ad-hoc-testing","title":"Ad-Hoc Testing","text":"<p>The first pass for testing a new command should be ad-hoc testing because it's the easiest way to get feedback during development. This entails running the command several times and manually checking that the output matches the expected.</p> <pre><code>$ flepimop2 hello --help\nUsage: flepimop2 hello [OPTIONS] [TIMES]\n\n  This command says hello a specified number of times.\n\nOptions:\n  --dry-run        Should this command be run using dry run?\n  -v, --verbosity  The verbosity level to use for this command.\n  --help           Show this message and exit.\n$ flepimop2 hello 3\n$ flepimop2 hello -v 3\n$ flepimop2 hello -vv 3\n2025-11-06 09:48:40,962:INFO&gt; (1/3) Hello, world!\n2025-11-06 09:48:40,962:INFO&gt; (2/3) Hello, world!\n2025-11-06 09:48:40,962:INFO&gt; (3/3) Hello, world!\n$ flepimop2 hello -vvv 3\n2025-11-06 09:48:46,452:DEBUG&gt; Given 2 options/arguments:\n2025-11-06 09:48:46,452:DEBUG&gt; times   = 3.\n2025-11-06 09:48:46,452:DEBUG&gt; dry_run = 0.\n2025-11-06 09:48:46,452:INFO&gt; (1/3) Hello, world!\n2025-11-06 09:48:46,452:INFO&gt; (2/3) Hello, world!\n2025-11-06 09:48:46,452:INFO&gt; (3/3) Hello, world!\n$ flepimop2 hello -vv --dry-run 5\n2025-11-06 09:49:00,106:INFO&gt; Would said hello 5 time(s).\n$ flepimop2 hello 0\nUsage: flepimop2 hello [OPTIONS] [TIMES]\nTry 'flepimop2 hello --help' for help.\n\nError: Invalid value for '[TIMES]': 0 is not in the range x&gt;=1.\n</code></pre> <p>This quick ad-hoc testing matches the following expected behavior:</p> <ul> <li>The command should only produce output at <code>-vv</code> and above because it uses the <code>info</code> method to log output.</li> <li>The command says \"Hello, world!\" the number of times given.</li> <li>Providing <code>--dry-run</code> does not repeat the greeting, but instead says it would have done so.</li> <li>Providing 0 or less for times results in an error that is caught before the command can run.</li> </ul>"},{"location":"development/adding-a-new-cli-command/#unit-testing","title":"Unit Testing","text":"<p>Ad-hoc testing is great for development purposes or diagnosing bugs quickly, but is not sustainable for long term maintenance. However, writing unit tests for CLI commands can be especially tricky because much of what CLI commands do is glue together behavior from other objects and emit output. Before unit testing a CLI command a developer should ask the following:</p> <ol> <li>Can this behavior and corresponding unit test be pushed down to the object being operated on or a new function? For example, suppose that <code>flepimop2 hello</code> worked with the <code>RunMeta</code> object and formatted the timestamp for display. In this case the formatting behavior should be added to the <code>RunMeta</code> object and tested there instead of testing that behavior via <code>HelloCommand</code>.</li> <li>Is the behavior essential to the CLI command? For example, the output logged to the user is non-essential. <code>flepimop2</code> does not make guarantees about CLI output consistency across versions. The only case where one might want to test the logged output is to see if a particular branch was reached, i.e. a certain message is only emitted if certain conditions are met.</li> </ol> <p>With that being said, the <code>flepimop2 hello</code> command does not have behavior that would be worth unit testing. For the purposes of unit testing change the <code>HelloCommand.run</code> method to:</p> <pre><code>...\n    def run(self, *, times: int, dry_run: bool) -&gt; None:  # type: ignore[override]\n        \"\"\"\n        Say hello a specified number of times.\n\n        Args:\n            times: The number of times to say hello.\n            dry_run: Whether dry run mode is enabled.\n\n        Raises:\n            ValueError: If `times` is greater than 10.\n        \"\"\"\n        if times &gt; 10:\n            msg = \"Cannot say hello more than 10 times.\"\n            raise ValueError(msg)\n        if dry_run:\n            self.info(f\"Would said hello {times} time(s).\")\n            return\n        for i in range(times):\n            self.info(f\"({i + 1}/{times}) Hello, world!\")\n</code></pre> <p>Now the command has behavior, raising an exception, that is worth testing and cannot be pushed to the object being operated on or an external function. To unit test this behavior add the following to <code>tests/_cli/test_hello_command.py</code>:</p> <pre><code>\"\"\"Unit tests for the `flepimop2 hello` CLI command.\"\"\"\n\nfrom flepimop2._cli._hello_command import HelloCommand\nimport pytest\n\n\ndef test_raises_value_error_if_times_exceeds_limit() -&gt; None:\n    \"\"\"Test that ValueError is raised if times &gt; 10.\"\"\"\n    command = HelloCommand()\n    with pytest.raises(ValueError, match=r\"Cannot say hello more than 10 times.\"):\n        command.run(times=11, dry_run=False)\n</code></pre> <p>Another benefit to <code>flepimop2</code>'s CLI infrastructure is that the <code>run</code> method of a <code>CliCommand</code> subclass can be tested directly rather than needing to use <code>subprocess.run</code> or <code>click.testing.CliRunner</code>. If the verbosity level needs to be controlled for a unit test a developer could modify this test by invoking <code>HelloCommand.__call__</code> instead with the same arguments as <code>run</code> but including verbosity like so:</p> <pre><code>\"\"\"Unit tests for the `flepimop2 hello` CLI command.\"\"\"\n\nfrom flepimop2._cli._hello_command import HelloCommand\nimport pytest\n\n\ndef test_raises_value_error_if_times_exceeds_limit() -&gt; None:\n    \"\"\"Test that ValueError is raised if times &gt; 10.\"\"\"\n    command = HelloCommand()\n    with pytest.raises(ValueError, match=r\"Cannot say hello more than 10 times.\"):\n        command(times=11, dry_run=False, verbosity=0)\n</code></pre>"},{"location":"development/adding-a-new-cli-command/#summary","title":"Summary","text":"<p>This tutorial covered:</p> <ul> <li>A high level overview of the <code>flepimop2</code> CLI infrastructure.</li> <li>Adding a new command to the <code>flepimop2</code> CLI.</li> <li>Adding a new option to <code>flepimop2</code>'s CLI infrastructure.</li> <li>Testing the newly added command.</li> </ul>"},{"location":"development/contributing/","title":"Contributing to <code>flepimop2</code>","text":"<p>This document provides guidelines and instructions for contributing to <code>flepimop2</code>, including development conventions and tips for best practices.</p>"},{"location":"development/contributing/#development-setup","title":"Development Setup","text":""},{"location":"development/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11, 3.12, 3.13, or 3.14.</li> <li><code>uv</code> - Python package manager.</li> <li><code>just</code> - Command runner (optional but strongly recommended).</li> </ul>"},{"location":"development/contributing/#initial-setup","title":"Initial Setup","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone git@github.com:ACCIDDA/flepimop2.git\ncd flepimop2\n</code></pre> <ol> <li>Create a virtual environment and install dependencies:</li> </ol> <pre><code>uv sync --dev\n</code></pre> <p>This creates a <code>.venv</code> virtual environment and installs the package along with all development dependencies (mypy, pytest, ruff, mkdocs). If you need to create an environment with a specific python version you can also run:</p> <pre><code>uv sync --dev --python 3.12\n</code></pre> <ol> <li>Verify your setup</li> </ol> <pre><code>just\n</code></pre> <p>This runs the default development checks:</p> <ul> <li><code>just ruff</code> - Format code and run lint checks with auto-fixes.</li> <li><code>just mypy</code> - Type check the codebase.</li> <li><code>just test</code> - Run non-integration tests with coverage and then integration tests.</li> <li><code>just yamllint</code> - Lint YAML files.</li> </ul> <p>It is recommended that you run this command frequently as you do development work to catch issues early.</p>"},{"location":"development/contributing/#code-standards","title":"Code Standards","text":""},{"location":"development/contributing/#style","title":"Style","text":"<p>We use <code>ruff</code> for both formatting and linting:</p> <ul> <li>Formatting: <code>ruff format</code> follows the Black code style.</li> <li>Linting: <code>ruff check</code> enforces code quality rules.</li> </ul> <p>Run <code>just</code> to automatically format/lint, type check, and run tests before committing. If you only want formatting/linting, run <code>just ruff</code>.</p>"},{"location":"development/contributing/#testing","title":"Testing","text":""},{"location":"development/contributing/#organization","title":"Organization","text":"<p>Tests are organized to mirror the source code structure:</p> <pre><code>tests/\n|-- {module}/\n|   |-- {submodule}/\n|   |   |-- test_{function}.py     # Tests for individual functions\n|   |   |-- test_{class}_class.py  # Tests for classes\n|   |-- test_{function}.py\n</code></pre> <p>Examples:</p> <ul> <li><code>tests/logging/test_get_script_logger.py</code> - Tests for the <code>get_script_logger</code> function.</li> <li><code>tests/logging/test_click_handler_class.py</code> - Tests for the <code>ClickHandler</code> class.</li> <li><code>tests/_cli/_options/test_get_option.py</code> - Tests for the <code>get_option</code> function.</li> <li><code>tests/configuration/test_fixed_parameter_specification_model_class.py</code> - Tests for the <code>FixedParameterSpecificationModel</code> class.</li> </ul>"},{"location":"development/contributing/#running-tests","title":"Running Tests","text":"<p>Test execution is split into explicit workflows:</p> <ul> <li><code>just test</code> - Local default test workflow (<code>just cov</code> then <code>just integration</code>).</li> <li><code>just cov</code> - Run tests marked <code>not integration</code>, report coverage, and enforce the configured minimum coverage threshold.</li> <li><code>just integration</code> - Run only tests marked <code>integration</code> (tests in <code>tests/integration/</code> are marked automatically).</li> <li><code>just pytest</code> - Run the full pytest suite (including integration tests) without coverage reporting.</li> </ul> <p>For more advanced test runs, use <code>pytest</code> directly:</p> <pre><code>uv run pytest tests/{module}/ -v                    # Run all tests in a module\nuv run pytest tests/{module}/test_{function}.py -v  # Run specific test file\n</code></pre> <p>For more information on how to invoke pytest please refer to the How to invoke pytest documentation.</p>"},{"location":"development/contributing/#writing-tests","title":"Writing Tests","text":"<ul> <li>Any public API should have unit tests that reaffirm the documentation's description.</li> <li>If possible unit tests should use <code>@pytest.mark.parametrize</code> for generality and ease of adding new test cases.</li> <li>Use descriptive test names that explain what is being tested. In the case of testing exceptions also the type of exception.</li> <li>For smaller helper functions, especially internal helpers, doctests are sufficient.</li> </ul>"},{"location":"development/contributing/#type-checking","title":"Type Checking","text":"<p>All code must pass strict type checking with <code>mypy</code> which can be invoked with <code>just mypy</code>. Note that <code>ruff</code> will catch missing type hints whereas <code>mypy</code> will check that those type hints are correct and consistent.</p>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<p>We use MkDocs for documentation.</p>"},{"location":"development/contributing/#editing-documentation","title":"Editing Documentation","text":"<p>Documentation files are located in the <code>docs/</code> directory:</p> <pre><code>docs/\n|-- index.md                # Home page\n|-- guides/\n    |-- getting-started.md  # Getting started guide\n</code></pre> <p>The documentation structure is defined in <code>mkdocs.yml</code>.</p>"},{"location":"development/contributing/#viewing-documentation-locally","title":"Viewing Documentation Locally","text":"<p>To preview documentation changes locally you can run <code>just serve</code> which will build the documentation and start a local server at <code>http://127.0.0.1:8000/flepimop2/</code>. To only build the documentation you can run <code>just docs</code> which will generate the documentation site in the <code>site/</code> directory.</p>"},{"location":"development/contributing/#documentation-testing","title":"Documentation Testing","text":"<p>In addition to unit tests and doctests, code contained in the documentation is also tested. This is run as a part of pytest-based commands (<code>just test</code>, <code>just cov</code>, <code>just pytest</code>). Each documentation page is treated as if it were one script so code blocks can reference previously created variables. To support this type of testing we use <code>Sybil</code>.</p>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"development/contributing/#before-submitting","title":"Before Submitting","text":"<ol> <li> <p>Run CI checks locally using <code>just ci</code>. This runs the same checks that CI will run:</p> </li> <li> <p><code>just quality</code> - CI quality checks (ruff check mode + mypy).</p> </li> <li><code>just test</code> - Coverage-gated non-integration tests and integration tests.</li> <li><code>just docs</code> - Documentation build checks.</li> </ol> <p>In GitHub Actions, these correspond to the <code>quality</code>, <code>tests</code>, and <code>docs</code> jobs in <code>.github/workflows/ci.yaml</code>.</p> <p>If you edit YAML files, also run <code>just yamllint</code>. YAML linting is separate from <code>just ci</code>.</p> <ol> <li> <p>Update documentation if your changes affect user-facing functionality or add features that require usage guides.</p> </li> <li> <p>Add tests for new functionality or bug fixes. Particularly for bug fixes, the test should be written before the fix and fail without the fix present.</p> </li> </ol>"},{"location":"development/contributing/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<ol> <li> <p>Create a branch from <code>main</code> and make your changes on this branch using the code standards above. Please use clear and descriptive commit messages that explain the changes made and why. After your work is finished either push directly to <code>flepimop2</code> or your fork (depending on your permissions).</p> </li> <li> <p>Create a pull request with:</p> </li> <li> <p>The motivation for and a clear description of the changes.</p> </li> <li>Link any related issues (use \"Closes #XYZ\" to auto-close issues).</li> <li>Explicitly point out the relevant documentation changes.</li> </ol>"},{"location":"development/contributing/#pull-request-requirements","title":"Pull Request Requirements","text":"<ul> <li>Tests run in CI against Python 3.11, 3.12, 3.13, and 3.14.</li> <li>Quality checks and documentation build checks run in CI on Python 3.12.</li> <li>At least one maintainer approval is required before merging.</li> <li>Branches must be up to date against <code>main</code> before merging and have a linear history. Only rebases are allowed for merging.</li> </ul>"},{"location":"development/contributing/#reporting-issues","title":"Reporting Issues","text":""},{"location":"development/contributing/#bug-reports","title":"Bug Reports","text":"<p>When reporting bugs, please include:</p> <ul> <li>Operating system and version.</li> <li>Python version (e.g., Python 3.12.1).</li> <li><code>flepimop2</code> version as a git commit hash.</li> <li>A minimal, reproducible example that demonstrates the issue.</li> <li>An explanation of expected behavior vs actual behavior.</li> <li>Error messages or tracebacks if applicable.</li> </ul>"},{"location":"development/contributing/#feature-requests","title":"Feature Requests","text":"<p>For feature requests, please:</p> <ul> <li>Check existing issues to avoid duplicates.</li> <li>Clearly describe the use case and motivation.</li> <li>Provide examples of how the feature would be used.</li> <li>Be open to discussion about implementation approaches.</li> </ul>"},{"location":"development/contributing/#questions","title":"Questions","text":"<p>For questions about using flepimop2:</p> <ul> <li>Check the documentation (which can be viewed locally with <code>just serve</code> for now).</li> <li>Search existing issues for similar questions.</li> <li>Open a new issue with the \"question\" label.</li> </ul>"},{"location":"development/creating-an-external-provider-package/","title":"Creating An External Provider Package","text":""},{"location":"development/creating-an-external-provider-package/#creating-an-external-provider-package","title":"Creating an External Provider Package","text":"<p>This tutorial will show how to:</p> <ul> <li>Create an external provider package that extends <code>flepimop2</code> functionality.</li> <li>Structure the package as a PEP 420 implicit namespace package.</li> <li>Implement a custom backend module class.</li> <li>Use the external provider package in a <code>flepimop2</code> configuration file.</li> </ul> <p>In this tutorial, we will create a new backend package called <code>flepimop2-npz-backend</code> that provides an <code>NpzBackend</code> class for saving and loading NumPy arrays using the <code>.npz</code> format.</p>"},{"location":"development/creating-an-external-provider-package/#what-is-an-external-provider-package","title":"What is an External Provider Package?","text":"<p>An external provider package allows users to extend <code>flepimop2</code> with custom implementations of systems, engines, backends, or processors without modifying the core <code>flepimop2</code> codebase. This is particularly useful for:</p> <ul> <li>Domain-specific models or algorithms.</li> <li>Custom file formats or storage backends.</li> <li>Specialized processing pipelines.</li> <li>Experimental features that may not be suitable for the core library.</li> </ul> <p>External provider packages leverage Python's namespace package mechanism to seamlessly integrate with <code>flepimop2</code>'s module resolution system.</p>"},{"location":"development/creating-an-external-provider-package/#brief-overview-of-namespace-packages","title":"Brief Overview of Namespace Packages","text":"<p><code>flepimop2</code> uses PEP 420 implicit namespace packages to allow external packages to contribute modules that can be referenced directly in configuration files. This means:</p> <ul> <li>External packages can add modules under the <code>flepimop2.*</code> namespace without conflicts.</li> <li>Users can reference modules by short names (e.g., <code>module: 'npz'</code>) instead of full paths.</li> <li><code>flepimop2</code> automatically resolves <code>module: 'npz'</code> to <code>flepimop2.backend.npz</code> when loading backend configurations.</li> </ul> <p>The key to making this work is:</p> <ol> <li>No <code>__init__.py</code> files in the namespace directories (e.g., <code>src/flepimop2/</code>, <code>src/flepimop2/backend/</code>)</li> <li>Proper configuration in <code>pyproject.toml</code> to tell the build system where to find the namespace packages</li> <li>Only the leaf module directory (e.g., <code>src/flepimop2/backend/npz/</code>) should have an <code>__init__.py</code> file</li> </ol> <p>For more details, see the Python Packaging Guide on Namespace Packages.</p>"},{"location":"development/creating-an-external-provider-package/#creating-the-external-provider-package","title":"Creating the External Provider Package","text":""},{"location":"development/creating-an-external-provider-package/#step-1-initialize-the-package-with-uv","title":"Step 1: Initialize the Package with <code>uv</code>","text":"<p>First, create a new Python package using <code>uv</code> with the <code>hatch</code> build backend:</p> <pre><code># Create a new directory for your package\nmkdir flepimop2-npz-backend\ncd flepimop2-npz-backend\n\n# Initialize a new Python package\nuv init --package --build-backend hatchling\n\n# Add dependencies\nuv add numpy\nuv add \"git+https://github.com/ACCIDDA/flepimop2\"\n</code></pre> <p>This creates a basic package structure with a <code>pyproject.toml</code> file configured to use the Hatch build backend.</p>"},{"location":"development/creating-an-external-provider-package/#step-2-configure-pyprojecttoml","title":"Step 2: Configure <code>pyproject.toml</code>","text":"<p>Edit the generated <code>pyproject.toml</code> file to configure the namespace package and add <code>flepimop2</code> as a dependency. Your <code>pyproject.toml</code> should look like this:</p> <pre><code>[project]\nname = \"flepimop2-npz-backend\"\nversion = \"0.1.0\"\ndescription = \"An external provider for flepimop2 for saving and reading npz files.\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.11\"\ndependencies = [\n    \"flepimop2\",\n    \"numpy&gt;=2.3.5\",\n]\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.targets.wheel]\npackages = [\"src/flepimop2\"]\n\n[tool.uv.sources]\nflepimop2 = { git = \"https://github.com/ACCIDDA/flepimop2\" }\n</code></pre> <p>The critical configuration here is <code>[tool.hatch.build.targets.wheel]</code>, which tells Hatch to package everything under <code>src/flepimop2</code> as part of the <code>flepimop2</code> namespace.</p>"},{"location":"development/creating-an-external-provider-package/#step-3-create-the-directory-structure","title":"Step 3: Create the Directory Structure","text":"<p>Create the following directory structure for your namespace package:</p> <pre><code>rm -r src/\nmkdir -p src/flepimop2/backend/npz\n</code></pre> <p>Do not create <code>__init__.py</code> files in <code>src/flepimop2/</code> or <code>src/flepimop2/backend/</code>. These directories must remain empty to function as namespace packages. Only create an <code>__init__.py</code> file in the leaf module directory.</p> <p>Your directory structure should look like this:</p> <pre><code>flepimop2-npz-backend/\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 flepimop2/          # NO __init__.py (namespace package)\n        \u2514\u2500\u2500 backend/        # NO __init__.py (namespace package)\n            \u2514\u2500\u2500 npz/        # This directory WILL have __init__.py\n                \u2514\u2500\u2500 __init__.py\n</code></pre> <p>The lack of <code>__init__.py</code> files in the intermediate directories (<code>flepimop2/</code> and <code>backend/</code>) is what makes them namespace packages, allowing multiple packages to contribute to the same namespace without conflicts.</p>"},{"location":"development/creating-an-external-provider-package/#step-4-implement-the-npzbackend-class","title":"Step 4: Implement the <code>NpzBackend</code> Class","text":"<p>Now we'll implement the <code>NpzBackend</code> class in <code>src/flepimop2/backend/npz/__init__.py</code>. Backends, similar to other modules, must implement the <code>BackendABC</code> class which defines the interface. There are two approaches to implementing a module class in <code>flepimop2</code>.</p>"},{"location":"development/creating-an-external-provider-package/#approach-1-inherit-from-modulemodel-recommended","title":"Approach 1: Inherit from <code>ModuleModel</code> (Recommended)","text":"<p>When you inherit from <code>ModuleModel</code>, your class becomes a Pydantic model that handles configuration validation automatically. You don't need to write a separate <code>build</code> function.</p> <pre><code>\"\"\"NPZ backend for flepimop2.\"\"\"\n\nimport os\nfrom pathlib import Path\nfrom typing import Literal\n\nimport numpy as np\nfrom flepimop2.typing import Float64NDArray\nfrom pydantic import Field, field_validator\n\nfrom flepimop2.abcs import BackendABC\nfrom flepimop2.configuration import ModuleModel\nfrom flepimop2.meta import RunMeta\n\n\nclass NpzBackend(ModuleModel, BackendABC):\n    \"\"\"NPZ backend for saving numpy arrays to .npz files.\"\"\"\n\n    module: Literal[\"flepimop2.backend.npz\"] = \"flepimop2.backend.npz\"\n    root: Path = Field(default_factory=lambda: Path.cwd() / \"model_output\")\n    compressed: bool = Field(default=True, description=\"Use compression when saving\")\n\n    @field_validator(\"root\", mode=\"after\")\n    @classmethod\n    def _validate_root(cls, root: Path) -&gt; Path:\n        \"\"\"\n        Validate that the root path is a writable directory.\n\n        Args:\n            root: The root path to validate.\n\n        Returns:\n            The validated root path.\n\n        Raises:\n            TypeError: If the root path is not a directory or is not writable.\n        \"\"\"\n        if not (root.is_dir() and os.access(root, os.W_OK)):\n            msg = f\"The specified 'root' is not a directory or is not writable: {root}\"\n            raise TypeError(msg)\n        return root\n\n    def _get_file_path(self, run_meta: RunMeta) -&gt; Path:\n        \"\"\"\n        Generate a dynamic file path based on run metadata.\n\n        Args:\n            run_meta: Metadata about the current run.\n\n        Returns:\n            The dynamically generated file path.\n        \"\"\"\n        timestamp_str = run_meta.timestamp.strftime(\"%Y%m%d_%H%M%S\")\n        name_part = f\"{run_meta.name}_\" if run_meta.name else \"\"\n        filename = f\"{name_part}{run_meta.action}_{timestamp_str}.npz\"\n        return self.root / filename\n\n    def _save(self, data: Float64NDArray, run_meta: RunMeta) -&gt; None:\n        \"\"\"\n        Save a numpy array to an NPZ file.\n\n        Args:\n            data: The numpy array to save.\n            run_meta: Metadata about the current run.\n        \"\"\"\n        file_path = self._get_file_path(run_meta)\n        file_path.parent.mkdir(parents=True, exist_ok=True)\n\n        if self.compressed:\n            np.savez_compressed(file_path, data=data)\n        else:\n            np.savez(file_path, data=data)\n\n    def _read(self, run_meta: RunMeta) -&gt; Float64NDArray:\n        \"\"\"\n        Read a numpy array from an NPZ file.\n\n        Args:\n            run_meta: Metadata about the current run.\n\n        Returns:\n            The numpy array read from the NPZ file.\n        \"\"\"\n        file_path = self._get_file_path(run_meta)\n        with np.load(file_path) as npz_file:\n            return npz_file[\"data\"]\n</code></pre> <p>The key points of this approach are:</p> <ul> <li>The class inherits from both <code>ModuleModel</code> and <code>BackendABC</code>.</li> <li>The <code>module</code> field uses a <code>Literal</code> type hint to specify the exact module path.</li> <li>Pydantic's <code>Field</code> is used to define configuration options with defaults and descriptions.</li> <li>Field validators can be used for custom validation logic.</li> <li>No separate <code>build</code> function is needed, <code>flepimop2</code> is able to inspect that this class inherits <code>ModuleModel</code> and creates a default <code>build</code> function.</li> </ul> <p>This is the generally recommended approach for constructing modules.</p>"},{"location":"development/creating-an-external-provider-package/#approach-2-custom-build-function","title":"Approach 2: Custom <code>build</code> Function","text":"<p>If you don't inherit from <code>ModuleModel</code>, you need to provide a custom <code>build</code> function that constructs your class from a configuration dictionary:</p> <pre><code>\"\"\"NPZ backend for flepimop2.\"\"\"\n\nimport os\nfrom pathlib import Path\nfrom typing import Any\n\nimport numpy as np\nfrom flepimop2.typing import Float64NDArray\n\nfrom flepimop2.abcs import BackendABC\nfrom flepimop2.configuration import ModuleModel\nfrom flepimop2.meta import RunMeta\n\n\nclass NpzBackend(BackendABC):\n    \"\"\"NPZ backend for saving numpy arrays to .npz files.\"\"\"\n\n    def __init__(self, root: Path | None = None, compressed: bool = True) -&gt; None:\n        \"\"\"\n        Initialize the NPZ backend.\n\n        Args:\n            root: The root directory for saving files. Defaults to ./model_output\n            compressed: Whether to use compression when saving. Defaults to True.\n\n        Raises:\n            TypeError: If root is not a writable directory.\n        \"\"\"\n        self.root = root if root is not None else Path.cwd() / \"model_output\"\n        self.compressed = compressed\n\n        if not (self.root.is_dir() and os.access(self.root, os.W_OK)):\n            msg = f\"The specified 'root' is not a directory or is not writable: {self.root}\"\n            raise TypeError(msg)\n\n    def _get_file_path(self, run_meta: RunMeta) -&gt; Path:\n        \"\"\"\n        Generate a dynamic file path based on run metadata.\n\n        Args:\n            run_meta: Metadata about the current run.\n\n        Returns:\n            The dynamically generated file path.\n        \"\"\"\n        timestamp_str = run_meta.timestamp.strftime(\"%Y%m%d_%H%M%S\")\n        name_part = f\"{run_meta.name}_\" if run_meta.name else \"\"\n        filename = f\"{name_part}{run_meta.action}_{timestamp_str}.npz\"\n        return self.root / filename\n\n    def _save(self, data: Float64NDArray, run_meta: RunMeta) -&gt; None:\n        \"\"\"\n        Save a numpy array to an NPZ file.\n\n        Args:\n            data: The numpy array to save.\n            run_meta: Metadata about the current run.\n        \"\"\"\n        file_path = self._get_file_path(run_meta)\n        file_path.parent.mkdir(parents=True, exist_ok=True)\n\n        if self.compressed:\n            np.savez_compressed(file_path, data=data)\n        else:\n            np.savez(file_path, data=data)\n\n    def _read(self, run_meta: RunMeta) -&gt; Float64NDArray:\n        \"\"\"\n        Read a numpy array from an NPZ file.\n\n        Args:\n            run_meta: Metadata about the current run.\n\n        Returns:\n            The numpy array read from the NPZ file.\n        \"\"\"\n        file_path = self._get_file_path(run_meta)\n        with np.load(file_path) as npz_file:\n            return npz_file[\"data\"]\n\n\ndef build(config: dict[str, Any] | ModuleModel) -&gt; NpzBackend:\n    \"\"\"\n    Build an NPZ backend from a configuration.\n\n    Args:\n        config: Configuration dictionary or ModuleModel containing backend settings.\n            Expected keys:\n            - root (optional): Path to the output directory\n            - compressed (optional): Whether to use compression\n\n    Returns:\n        An instance of NpzBackend.\n    \"\"\"\n    config_dict = config.model_dump() if isinstance(config, ModuleModel) else config\n    config_dict = {k: v for k, v in config.items() if k != \"module\"}\n    if \"root\" in config_dict and isinstance(config_dict[\"root\"], str):\n        config_dict[\"root\"] = Path(config_dict[\"root\"])\n    return NpzBackend(**config_dict)\n</code></pre> <p>The key points of this approach are:</p> <ul> <li>The class only inherits from <code>BackendABC</code>, not <code>ModuleModel</code>.</li> <li>Manual validation is performed in <code>__init__</code>.</li> <li>A separate <code>build</code> function is required to construct instances from configuration.</li> <li>The <code>build</code> function must handle both <code>dict</code> and <code>ModuleModel</code> inputs.</li> <li>More manual work, but provides complete control over instantiation.</li> </ul> <p>This approach is generally not recommended unless you have very advanced needs that Pydantic based configuration parsing and validating does not support.</p>"},{"location":"development/creating-an-external-provider-package/#step-5-install-the-package","title":"Step 5: Install the Package","text":"<p>Install your package in development mode:</p> <pre><code>uv pip install -e .\n</code></pre> <p>This makes the <code>flepimop2.backend.npz</code> module available to <code>flepimop2</code>.</p>"},{"location":"development/creating-an-external-provider-package/#step-6-use-the-backend-in-a-configuration-file","title":"Step 6: Use the Backend in a Configuration File","text":"<p>Now you can use your custom backend in a <code>flepimop2</code> configuration file with <code>module: 'npz'</code> like so:</p> <pre><code>backend:\n  - module: 'npz'\n    root: './npz_output'\n    compressed: true\n</code></pre> <p>When <code>flepimop2</code> processes this configuration:</p> <ol> <li>It sees <code>module: 'npz'</code> in the backend section.</li> <li>It prepends <code>flepimop2.backend.</code> to resolve it to <code>flepimop2.backend.npz</code>.</li> <li>It imports the module from your external package.</li> <li>If using Approach 1, it instantiates <code>NpzBackend</code> directly using a default <code>build</code> function.</li> <li>If using Approach 2, it calls the <code>build</code> function with the configuration.</li> </ol>"},{"location":"development/creating-an-external-provider-package/#testing-your-external-provider-package","title":"Testing Your External Provider Package","text":"<p>It's important to test your external provider package to ensure it integrates correctly with <code>flepimop2</code>. Here's a minimal unit test:</p> <pre><code>\"\"\"Unit test for NPZ backend.\"\"\"\n\nfrom pathlib import Path\nimport numpy as np\nfrom flepimop2.backend.npz import NpzBackend\nfrom flepimop2.meta import RunMeta\n\n\ndef test_npz_backend_save_and_load(tmp_path: Path) -&gt; None:\n    \"\"\"Test that NPZ backend can save and load data.\"\"\"\n    # Create backend instance\n    backend = NpzBackend(root=tmp_path, compressed=True)\n\n    # Create test data\n    test_data = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n\n    # Create run metadata\n    run_meta = RunMeta(name=\"test\", action=\"simulate\")\n\n    # Save data\n    backend.save(test_data, run_meta)\n\n    # Verify file was created\n    output_files = list(tmp_path.glob(\"*.npz\"))\n    assert len(output_files) == 1\n\n    # Load data and verify it matches\n    loaded_data = backend.read(run_meta)\n    np.testing.assert_array_equal(loaded_data, test_data)\n</code></pre>"},{"location":"development/creating-an-external-provider-package/#summary","title":"Summary","text":"<p>This tutorial covered:</p> <ul> <li>What external provider packages are and why they're useful.</li> <li>How PEP 420 namespace packages enable seamless integration with <code>flepimop2</code>.</li> <li>Creating a new external provider package using <code>uv</code> and <code>hatchling</code>.</li> <li>Proper directory structure for namespace packages (no <code>__init__.py</code> in intermediate directories).</li> <li>Two approaches for implementing module classes:</li> <li>Inheriting from <code>ModuleModel</code> for automatic Pydantic validation (recommended).</li> <li>Using a custom <code>build</code> function for complete control.</li> <li>Using your external provider package in <code>flepimop2</code> configuration files.</li> <li>Testing your external provider package.</li> </ul> <p>With this knowledge, you can extend <code>flepimop2</code> with custom systems, engines, backends, and processors that integrate seamlessly with the core framework.</p>"},{"location":"development/implementing-custom-engines-and-systems/","title":"Implementing Custom Engines and Systems","text":"<p>This guide shows how to implement <code>EngineABC</code> and <code>SystemABC</code> so they can be loaded by <code>flepimop2</code> and used in simulations. It mirrors the style of the external provider guide, but focuses only on the engine/system interfaces.</p> <p>Below is a minimal example creating new <code>EulerEngine</code> and <code>SirSystem</code>. You can copy these into your own module(s) under the <code>flepimop2.engine</code> and <code>flepimop2.system</code> namespaces.</p>"},{"location":"development/implementing-custom-engines-and-systems/#what-are-systems-and-engines","title":"What are systems and engines?","text":"<ul> <li>System: implements the model dynamics via a stepper and advertises its properties via the standardized required attributes or non-standardized options.</li> <li>Engine: runs a system stepper over time using an <code>EngineABC</code> runner.</li> <li>Compatibility: engines may validate system properties (e.g., flow vs. delta vs. state semantics) before running.</li> </ul>"},{"location":"development/implementing-custom-engines-and-systems/#system-implementation-sirsystem","title":"System Implementation (<code>SirSystem</code>)","text":"<pre><code>\"\"\"Stepper function for SIR model integration tests.\"\"\"\n\nfrom typing import Any\n\nimport numpy as np\n\nfrom flepimop2.configuration import ModuleModel\nfrom flepimop2.system.abc import SystemABC\nfrom flepimop2.typing import Float64NDArray, StateChangeEnum\n\n\ndef stepper(\n    time: np.float64,  # noqa: ARG001\n    state: Float64NDArray,\n    **kwargs: Any,  # noqa: ARG001\n) -&gt; Float64NDArray:\n    \"\"\"\n    ODE for an SIR model.\n\n    Args:\n        time: Current time (not used in this model).\n        state: Current state array [S, I, R].\n        **kwargs: Additional parameters (e.g. beta, gamma, etc.).\n\n    Returns:\n        The change in state.\n    \"\"\"\n    # Implementors add their own logic here\n    pass\n\n\nclass SirSystem(SystemABC):\n    \"\"\"SIR model system.\"\"\"\n\n    module = \"flepimop2.system.sir\"\n    state_change = StateChangeEnum.FLOW\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the SIR system with the SIR stepper.\"\"\"\n        self._stepper = stepper\n\n\ndef build(config: dict[str, Any] | ModuleModel) -&gt; SirSystem:  # noqa: ARG001\n    \"\"\"\n    Build an SIR system.\n\n    Returns:\n        An instance of the SIR system.\n    \"\"\"\n    return SirSystem()\n</code></pre> <p>Key elements in the system implementation:</p> <ul> <li><code>stepper</code> defines the model dynamics which the engine will call it repeatedly.</li> <li><code>SirSystem</code> inherits <code>SystemABC</code> and assigns <code>_stepper</code> in <code>__init__</code> as well as has the required attributes <code>module</code> and <code>state_change</code>.</li> <li><code>build(...)</code> provides a standard entry point so <code>flepimop2</code> can construct the system from configuration data. For more details on this you can read the Creating An External Provider Package development guide.</li> </ul>"},{"location":"development/implementing-custom-engines-and-systems/#engine-implementation-eulerengine","title":"Engine Implementation (<code>EulerEngine</code>)","text":"<pre><code>\"\"\"Runner function for SIR model integration tests.\"\"\"\n\nfrom typing import Any\n\nimport numpy as np\n\nfrom flepimop2.configuration import IdentifierString, ModuleModel\nfrom flepimop2.engine.abc import EngineABC\nfrom flepimop2.exceptions import ValidationIssue\nfrom flepimop2.system.abc import SystemABC, SystemProtocol\nfrom flepimop2.typing import Float64NDArray\n\n\ndef runner(\n    stepper: SystemProtocol,\n    times: Float64NDArray,\n    state: Float64NDArray,\n    params: dict[IdentifierString, Any],\n    **kwargs: Any,  # noqa: ARG001\n) -&gt; Float64NDArray:\n    \"\"\"\n    Simple Euler runner for the SIR model.\n\n    Args:\n        stepper: The system stepper function.\n        times: Array of time points.\n        state: The current state array.\n        params: Additional parameters for the stepper.\n        **kwargs: Additional keyword arguments for the engine. Unused by this runner.\n\n    Returns:\n        The evolved time x state array.\n    \"\"\"\n    # Implementors add their own logic here\n    pass\n\n\nclass EulerEngine(EngineABC):\n    \"\"\"SIR model runner.\"\"\"\n\n    module = \"flepimop2.engine.euler\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the SIR runner with the SIR runner function.\"\"\"\n        self._runner = runner\n\n    def validate_system(self, system: SystemABC) -&gt; list[ValidationIssue] | None:\n        \"\"\"\n        Validation hook for system properties.\n\n        Args:\n            system: The system to validate.\n\n        Returns:\n            A list of validation issues, or `None` if not implemented.\n        \"\"\"\n        if system.state_change != StateChangeEnum.FLOW:\n            return [\n                ValidationIssue(\n                    msg=(\n                        \"Engine state change type, 'flow', is not \"\n                        \"compatible with system state change type \"\n                        f\"'{system.state_change}'.\"\n                    ),\n                    kind=\"incompatible_system\",\n                )\n            ]\n        return None\n\n\ndef build(config: dict[str, Any] | ModuleModel) -&gt; EulerEngine:  # noqa: ARG001\n    \"\"\"\n    Build an SIR engine.\n\n    Returns:\n        An instance of the SIR engine.\n    \"\"\"\n    return EulerEngine()\n</code></pre> <p>Key elements in the engine implementation:</p> <ul> <li><code>runner</code> drives the simulation by applying the stepper across time points.</li> <li><code>EulerEngine</code> inherits <code>EngineABC</code> and assigns <code>_runner</code> in <code>__init__</code> as well as has a <code>module</code> attribute that gives it an importable name.</li> <li><code>EulerEngine</code> implements the optional <code>validate_system</code> hook to ensure that the system is compatible.</li> <li><code>build(...)</code> lets <code>flepimop2</code> construct the engine from configuration data.</li> </ul>"},{"location":"development/implementing-custom-engines-and-systems/#summary","title":"Summary","text":"<p>Custom engines and systems are simple to implement once you know the required hooks. Keep the interfaces small and explicit, and let <code>flepimop2</code> handle construction and validation.</p> <ul> <li>Systems must supply a stepper function as well as required attributes <code>module</code> and <code>state_change</code>.</li> <li>Engines must supply a runner function compatible with <code>SystemProtocol</code> as well as required attributes <code>module</code> and optional system validation hook <code>validate_system</code>.</li> <li><code>build(...)</code> provides the standard entry point for configuration-driven construction.</li> </ul>"},{"location":"development/integration-testing/","title":"Integration Testing","text":"<p>This tutorial will show how to:</p> <ul> <li>Use <code>flepimop2.testing</code> helpers to run end-to-end scenarios.</li> <li>Validate real CLI behavior in a project context or an external provider package context.</li> </ul>"},{"location":"development/integration-testing/#why-do-integration-test","title":"Why do Integration Test?","text":"<p>Integration tests are for checking that packages behave as a user would expect when used with the <code>flepimop2</code> CLI and infrastructure. They are slower than unit tests because they create projects, invoke commands, and run simulations. That cost is worth it when you want confidence that all the pieces work together.</p> <p>Because they are slower, integration tests should be broad. Prefer a single test that exercises a full workflow with several assertions rather than lots of tiny variants. Use unit tests for edge cases and fast iteration, and use integration tests for end-to-end scenarios.</p>"},{"location":"development/integration-testing/#integration-testing-in-a-project-context","title":"Integration Testing in a Project Context","text":"<p>The most common type of integration testing, especially for developers of external package providers, is running the <code>flepimop2</code> CLI in a project context. The primary functions a user will use are <code>project_skeleton</code>, which will setup a project in the given directory, and <code>flepimop2_run</code>, which will run the <code>flepimop2</code> CLI in the context of that project.</p> tests/integration/my_integration_test/test_simulate.py<pre><code>from pathlib import Path\n\nfrom flepimop2.testing import flepimop2_run, project_skeleton\n\ndef test_simulate(tmp_path: Path) -&gt; None:\n    project_skeleton(\n        tmp_path,\n        copy_files={\n            Path(\"tests/integration/my_integration_test/sir.py\"): Path(\n                \"model_input/plugins/sir.py\"\n            ),\n            Path(\"tests/integration/my_integration_test/solve_ivp.py\"): Path(\n                \"model_input/plugins/solve_ivp.py\"\n            ),\n            Path(\"tests/integration/my_integration_test/config.yaml\"): Path(\n                \"configs/config.yaml\"\n            ),\n        },\n        dependencies=[\"numpy\", \"pandas\", \"scipy\"],\n    )\n    result = flepimop2_run(\n        \"simulate\",\n        args=[\"configs/config.yaml\"],\n        cwd=tmp_path,\n    )\n    assert result.returncode == 0\n</code></pre> <p>Above is a brief example of what an integration test might look like. The key elements of this example are:</p> <ul> <li>The test provides a temporary directory to <code>project_skeleton</code> and <code>flepimop2_run</code> that is cleaned up after test completion via <code>pytest</code>'s <code>tmp_path</code> fixture.</li> <li>The files <code>sir.py</code>, <code>solve_ivp.py</code>, and <code>config.yaml</code> are copied from the integration test to the project directory after the project is created via the <code>flepimop2 skeleton</code> CLI.</li> <li>The dependencies <code>numpy</code>, <code>pandas</code>, and <code>scipy</code> are additionally installed to the project directory's virtual environment and are available to the <code>flepimop2</code> CLI.</li> <li>Finally, the <code>flepimop2_run</code> function invokes the <code>flepimop2 simulate</code> CLI in the project directory and the returned object is a <code>subprocess.CompletedProcess</code>. However, you could invoke any action available via the <code>flepimop2</code> CLI, for a full list please refer to <code>flepimop2 --help</code>.</li> </ul> <p>From here a developer would be able to make further assertions about the output of the CLI command itself or contents of the project directory to ensure that the integration test has worked as expected.</p>"},{"location":"development/integration-testing/#integration-testing-in-an-external-provider-package-context","title":"Integration Testing in an External Provider Package Context","text":"<p>For tests that need to simulate an external provider package, use <code>external_provider_package</code>. This helper constructs an implicit namespace package under <code>flepimop2.*</code>, installs it into a temporary virtual environment, and lets you run the CLI against it using <code>flepimop2_run</code>. This kind of integration test is very uncommon outside of development for <code>flepimop2</code> itself since this is largely about testing the ability for the <code>flepimop2</code> package to interact with external package providers.</p> tests/integration/external_provider/test_simulate.py<pre><code>from pathlib import Path\n\nfrom flepimop2.testing import external_provider_package, flepimop2_run\n\ndef test_simulate(tmp_path: Path) -&gt; None:\n    external_provider_package(\n        tmp_path,\n        copy_files={\n            Path(\"tests/integration/external_provider/euler.py\"): Path(\n                \"external_provider/src/flepimop2/engine/euler.py\"\n            ),\n            Path(\"tests/integration/external_provider/sir.py\"): Path(\n                \"external_provider/src/flepimop2/system/sir.py\"\n            ),\n            Path(\"tests/integration/external_provider/config.yaml\"): Path(\n                \"config.yaml\"\n            ),\n        },\n        dependencies=[\"numpy\", \"scipy\"],\n    )\n    result = flepimop2_run(\n        \"simulate\",\n        args=[\"config.yaml\"],\n        cwd=tmp_path,\n    )\n    assert result.returncode == 0\n</code></pre> <p>Above is a brief example of what an integration test might look like. Similar to the previous example, the key elements of this example are the same, except the <code>external_provider_package</code> creates an external provider package named \"example-provider\".</p>"},{"location":"development/integration-testing/#summary","title":"Summary","text":"<p>Integration tests validate the end-to-end user experience of <code>flepimop2</code> using real projects and real CLI commands. Use <code>project_skeleton</code> for project workflows, and use <code>external_provider_package</code> when you need to simulate a provider package install.</p> <p>For API details please refer to the <code>flepimop2.testing</code> API reference and for working examples you can refer to the <code>flepimop2</code> integration tests.</p>"},{"location":"guides/getting-started/","title":"Getting Started","text":"<p>A brief tutorial on how to get started with <code>flepimop2</code>.</p> <pre><code>import math\nfoo = 2 * math.pi\n</code></pre> <p>And then</p> <pre><code>&gt;&gt;&gt; foo\n6.283185307179586\n</code></pre>"},{"location":"reference/cli/","title":"CLI","text":""},{"location":"reference/cli/#flepimop2","title":"flepimop2","text":"<p>flepimop2 - Flexible Epidemic Modeling Pipeline (version 2).</p> <p>Usage:</p> <pre><code>flepimop2 [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --version  Show the version and exit.\n  --help     Show this message and exit.\n</code></pre>"},{"location":"reference/cli/#flepimop2-build","title":"flepimop2 build","text":"<p>Compile and build a model defined in a configuration file.</p> <p>Usage:</p> <pre><code>flepimop2 build [OPTIONS] CONFIG\n</code></pre> <p>Options:</p> <pre><code>  --dry-run        Should this command be run using dry run?\n  -v, --verbosity  The verbosity level to use for this command.\n  --help           Show this message and exit.\n</code></pre>"},{"location":"reference/cli/#flepimop2-process","title":"flepimop2 process","text":"<p>Execute a processing step based on a configuration file.</p> <p>The <code>CONFIG</code> argument should point to a valid configuration file.</p> <p>Usage:</p> <pre><code>flepimop2 process [OPTIONS] CONFIG\n</code></pre> <p>Options:</p> <pre><code>  --dry-run          Should this command be run using dry run?\n  -t, --target TEXT  The target to use for this command.\n  -v, --verbosity    The verbosity level to use for this command.\n  --help             Show this message and exit.\n</code></pre>"},{"location":"reference/cli/#flepimop2-simulate","title":"flepimop2 simulate","text":"<p>Run simulations based on a configuration file.</p> <p>This command runs epidemic simulations specified from a provided configuration file. The <code>CONFIG</code> argument should point to a valid configuration file.</p> <p>Usage:</p> <pre><code>flepimop2 simulate [OPTIONS] CONFIG\n</code></pre> <p>Options:</p> <pre><code>  --dry-run          Should this command be run using dry run?\n  -t, --target TEXT  The target to use for this command.\n  -v, --verbosity    The verbosity level to use for this command.\n  --help             Show this message and exit.\n</code></pre>"},{"location":"reference/cli/#flepimop2-skeleton","title":"flepimop2 skeleton","text":"<p>Create a project skeleton with directory structure and template files.</p> <p>This command scaffolds a new flepimop2 project by creating the necessary directory structure and populating it with template configuration files, environment specifications, and other boilerplate files needed to get started.</p> <p>The <code>PATH</code> argument specifies where to create the project. If omitted, the skeleton will be created in the current working directory.</p> <p>Examples:     # Create an empty project in a new directory     $ flepimop2 skeleton foobar     # Create a project in the current directory     $ mkdir fizzbuzz &amp;&amp; cd fizzbuzz     $ flepimop2 skeleton</p> <p>Usage:</p> <pre><code>flepimop2 skeleton [OPTIONS] [PATH]\n</code></pre> <p>Options:</p> <pre><code>  --dry-run        Should this command be run using dry run?\n  -v, --verbosity  The verbosity level to use for this command.\n  --help           Show this message and exit.\n</code></pre>"},{"location":"reference/api/abcs/","title":"Abcs","text":""},{"location":"reference/api/abcs/#flepimop2.abcs","title":"<code>abcs</code>","text":"<p>Abstract base classes for flepimop2 modules.</p> <p>This module provides abstract base classes (ABCs) for key modules of the flepimop2 pipeline. The ABCs defined here can also be found in their respective submodules, but are re-exported here for developer convenience.</p>"},{"location":"reference/api/abcs/#flepimop2.abcs.BackendABC","title":"<code>BackendABC</code>","text":"<p>               Bases: <code>ModuleABC</code></p> <p>Abstract base class for flepimop2 file IO backends.</p>"},{"location":"reference/api/abcs/#flepimop2.abcs.BackendABC.read","title":"<code>read(run_meta)</code>","text":"<p>Read a numpy array from storage.</p> <p>Parameters:</p> Name Type Description Default <code>run_meta</code> <code>RunMeta</code> <p>Metadata about the current run.</p> required <p>Returns:</p> Type Description <code>Float64NDArray</code> <p>The numpy array read from storage.</p> Source code in <code>src/flepimop2/backend/abc/__init__.py</code> <pre><code>def read(self, run_meta: RunMeta) -&gt; Float64NDArray:\n    \"\"\"\n    Read a numpy array from storage.\n\n    Args:\n        run_meta: Metadata about the current run.\n\n    Returns:\n        The numpy array read from storage.\n    \"\"\"\n    return self._read(run_meta)\n</code></pre>"},{"location":"reference/api/abcs/#flepimop2.abcs.BackendABC.save","title":"<code>save(data, run_meta)</code>","text":"<p>Save a numpy array to storage.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Float64NDArray</code> <p>The numpy array to save.</p> required <code>run_meta</code> <code>RunMeta</code> <p>Metadata about the current run.</p> required Source code in <code>src/flepimop2/backend/abc/__init__.py</code> <pre><code>def save(self, data: Float64NDArray, run_meta: RunMeta) -&gt; None:\n    \"\"\"\n    Save a numpy array to storage.\n\n    Args:\n        data: The numpy array to save.\n        run_meta: Metadata about the current run.\n    \"\"\"\n    return self._save(data, run_meta)\n</code></pre>"},{"location":"reference/api/abcs/#flepimop2.abcs.EngineABC","title":"<code>EngineABC(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModuleABC</code></p> <p>Abstract class for Engines to evolve Dynamic Systems.</p> <p>Initialize the EngineABC.</p> <p>The default initialization sets the runner to a no-op function. Concrete implementations should override this with a valid runner function.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments.</p> <code>{}</code> Source code in <code>src/flepimop2/engine/abc/__init__.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ARG002\n    \"\"\"\n    Initialize the EngineABC.\n\n    The default initialization sets the runner to a no-op function. Concrete\n    implementations should override this with a valid runner function.\n\n    Args:\n        *args: Positional arguments.\n        **kwargs: Keyword arguments.\n    \"\"\"\n    self._runner = _no_run_func\n</code></pre>"},{"location":"reference/api/abcs/#flepimop2.abcs.EngineABC.run","title":"<code>run(system, eval_times, initial_state, params, **kwargs)</code>","text":"<p>Run the engine with the provided system and parameters.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>SystemABC</code> <p>The dynamic system to be evolved.</p> required <code>eval_times</code> <code>Float64NDArray</code> <p>Array of time points for evaluation.</p> required <code>initial_state</code> <code>Float64NDArray</code> <p>The initial state array.</p> required <code>params</code> <code>dict[IdentifierString, Any]</code> <p>Additional parameters for the stepper.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the engine.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Float64NDArray</code> <p>The evolved time x state array.</p> Source code in <code>src/flepimop2/engine/abc/__init__.py</code> <pre><code>def run(\n    self,\n    system: SystemABC,\n    eval_times: Float64NDArray,\n    initial_state: Float64NDArray,\n    params: dict[IdentifierString, Any],\n    **kwargs: Any,\n) -&gt; Float64NDArray:\n    \"\"\"\n    Run the engine with the provided system and parameters.\n\n    Args:\n        system: The dynamic system to be evolved.\n        eval_times: Array of time points for evaluation.\n        initial_state: The initial state array.\n        params: Additional parameters for the stepper.\n        **kwargs: Additional keyword arguments for the engine.\n\n    Returns:\n        The evolved time x state array.\n    \"\"\"\n    return self._runner(\n        system._stepper,  # noqa: SLF001\n        eval_times,\n        initial_state,\n        params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/api/abcs/#flepimop2.abcs.EngineABC.validate_system","title":"<code>validate_system(system)</code>","text":"<p>Validation hook for system properties.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>SystemABC</code> <p>The system to validate.</p> required <p>Returns:</p> Type Description <code>list[ValidationIssue] | None</code> <p>A list of validation issues, or <code>None</code> if not implemented.</p> Source code in <code>src/flepimop2/engine/abc/__init__.py</code> <pre><code>def validate_system(  # noqa: PLR6301\n    self,\n    system: SystemABC,  # noqa: ARG002\n) -&gt; list[ValidationIssue] | None:\n    \"\"\"\n    Validation hook for system properties.\n\n    Args:\n        system: The system to validate.\n\n    Returns:\n        A list of validation issues, or `None` if not implemented.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/api/abcs/#flepimop2.abcs.EngineProtocol","title":"<code>EngineProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Type-definition (Protocol) for engine runner functions.</p>"},{"location":"reference/api/abcs/#flepimop2.abcs.EngineProtocol.__call__","title":"<code>__call__(stepper, times, state, params, **kwargs)</code>","text":"<p>Protocol for engine runner functions.</p> Source code in <code>src/flepimop2/engine/abc/__init__.py</code> <pre><code>def __call__(\n    self,\n    stepper: SystemProtocol,\n    times: Float64NDArray,\n    state: Float64NDArray,\n    params: dict[IdentifierString, Any],\n    **kwargs: Any,\n) -&gt; Float64NDArray:\n    \"\"\"Protocol for engine runner functions.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/api/abcs/#flepimop2.abcs.ParameterABC","title":"<code>ParameterABC</code>","text":"<p>               Bases: <code>ModuleABC</code></p> <p>Abstract base class for parameters.</p>"},{"location":"reference/api/abcs/#flepimop2.abcs.ParameterABC.sample","title":"<code>sample()</code>  <code>abstractmethod</code>","text":"<p>Sample a value from the parameter.</p> <p>Returns:</p> Type Description <code>Float64NDArray</code> <p>A sampled value from the parameter.</p> Source code in <code>src/flepimop2/parameter/abc/__init__.py</code> <pre><code>@abstractmethod\ndef sample(self) -&gt; Float64NDArray:\n    \"\"\"Sample a value from the parameter.\n\n    Returns:\n        A sampled value from the parameter.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/api/abcs/#flepimop2.abcs.ProcessABC","title":"<code>ProcessABC</code>","text":"<p>               Bases: <code>ModuleABC</code></p> <p>Abstract base class for flepimop2 processing steps.</p>"},{"location":"reference/api/abcs/#flepimop2.abcs.ProcessABC.execute","title":"<code>execute(*, dry_run=False)</code>","text":"<p>Execute a processing step.</p> <p>Parameters:</p> Name Type Description Default <code>dry_run</code> <code>bool</code> <p>If True, the process will not actually execute but will simulate execution.</p> <code>False</code> <p>Raises:</p> Type Description <code>Flepimop2ValidationError</code> <p>If validation fails during a dry run.</p> Source code in <code>src/flepimop2/process/abc/__init__.py</code> <pre><code>def execute(self, *, dry_run: bool = False) -&gt; None:\n    \"\"\"\n    Execute a processing step.\n\n    Args:\n        dry_run: If True, the process will not actually execute but will simulate\n            execution.\n\n    Raises:\n        Flepimop2ValidationError: If validation fails during a dry run.\n    \"\"\"\n    if dry_run and (result := self._process_validate()) is not None:\n        if result:\n            raise Flepimop2ValidationError(result)\n        return None\n    return self._process(dry_run=dry_run)\n</code></pre>"},{"location":"reference/api/abcs/#flepimop2.abcs.SystemABC","title":"<code>SystemABC(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModuleABC</code></p> <p>Abstract class for Dynamic Systems.</p> <p>Attributes:</p> Name Type Description <code>module</code> <code>str</code> <p>The module name for the system.</p> <code>state_change</code> <code>StateChangeEnum</code> <p>The type of state change.</p> <code>options</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of additional options the system exposes for <code>flepimop2</code> to take advantage of.</p> <p>Initialize the SystemABC.</p> <p>The default initialization sets the stepper to a no-op function. Concrete implementations should override this with a valid stepper function.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments.</p> <code>{}</code> Source code in <code>src/flepimop2/system/abc/__init__.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ARG002\n    \"\"\"\n    Initialize the SystemABC.\n\n    The default initialization sets the stepper to a no-op function. Concrete\n    implementations should override this with a valid stepper function.\n\n    Args:\n        *args: Positional arguments.\n        **kwargs: Keyword arguments.\n    \"\"\"\n    self._stepper = _no_step_function\n</code></pre>"},{"location":"reference/api/abcs/#flepimop2.abcs.SystemABC.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"<p>Ensure concrete subclasses define a valid state change type.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to parent classes.</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If a concrete subclass does not define <code>state_change</code>.</p> Source code in <code>src/flepimop2/system/abc/__init__.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Ensure concrete subclasses define a valid state change type.\n\n    Args:\n        **kwargs: Additional keyword arguments passed to parent classes.\n\n    Raises:\n        TypeError: If a concrete subclass does not define `state_change`.\n\n    \"\"\"\n    super().__init_subclass__(**kwargs)\n    if inspect.isabstract(cls):\n        return\n    annotations = inspect.get_annotations(cls)\n    has_state_change = (\n        \"state_change\" in cls.__dict__ or \"state_change\" in annotations\n    )\n    if not has_state_change:\n        msg = (\n            f\"Concrete class '{cls.__name__}' must define 'state_change' as \"\n            \"a class attribute or type annotation.\"\n        )\n        raise TypeError(msg)\n</code></pre>"},{"location":"reference/api/abcs/#flepimop2.abcs.SystemABC.step","title":"<code>step(time, state, **params)</code>","text":"<p>Perform a single step of the system's dynamics.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float64</code> <p>The current time.</p> required <code>state</code> <code>Float64NDArray</code> <p>The current state array.</p> required <code>**params</code> <code>Any</code> <p>Additional parameters for the stepper.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Float64NDArray</code> <p>The next state array after one step.</p> Source code in <code>src/flepimop2/system/abc/__init__.py</code> <pre><code>def step(\n    self, time: np.float64, state: Float64NDArray, **params: Any\n) -&gt; Float64NDArray:\n    \"\"\"\n    Perform a single step of the system's dynamics.\n\n    Args:\n        time: The current time.\n        state: The current state array.\n        **params: Additional parameters for the stepper.\n\n    Returns:\n        The next state array after one step.\n    \"\"\"\n    return self._stepper(time, state, **params)\n</code></pre>"},{"location":"reference/api/abcs/#flepimop2.abcs.SystemProtocol","title":"<code>SystemProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Type-definition (Protocol) for system stepper functions.</p>"},{"location":"reference/api/abcs/#flepimop2.abcs.SystemProtocol.__call__","title":"<code>__call__(time, state, **kwargs)</code>","text":"<p>Protocol for system stepper functions.</p> Source code in <code>src/flepimop2/system/abc/__init__.py</code> <pre><code>def __call__(\n    self, time: np.float64, state: Float64NDArray, **kwargs: Any\n) -&gt; Float64NDArray:\n    \"\"\"Protocol for system stepper functions.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/api/backend/","title":"Backend","text":""},{"location":"reference/api/backend/#flepimop2.backend.abc","title":"<code>abc</code>","text":"<p>Abstract base class for flepimop2 file IO backends.</p>"},{"location":"reference/api/backend/#flepimop2.backend.abc.BackendABC","title":"<code>BackendABC</code>","text":"<p>               Bases: <code>ModuleABC</code></p> <p>Abstract base class for flepimop2 file IO backends.</p>"},{"location":"reference/api/backend/#flepimop2.backend.abc.BackendABC.read","title":"<code>read(run_meta)</code>","text":"<p>Read a numpy array from storage.</p> <p>Parameters:</p> Name Type Description Default <code>run_meta</code> <code>RunMeta</code> <p>Metadata about the current run.</p> required <p>Returns:</p> Type Description <code>Float64NDArray</code> <p>The numpy array read from storage.</p> Source code in <code>src/flepimop2/backend/abc/__init__.py</code> <pre><code>def read(self, run_meta: RunMeta) -&gt; Float64NDArray:\n    \"\"\"\n    Read a numpy array from storage.\n\n    Args:\n        run_meta: Metadata about the current run.\n\n    Returns:\n        The numpy array read from storage.\n    \"\"\"\n    return self._read(run_meta)\n</code></pre>"},{"location":"reference/api/backend/#flepimop2.backend.abc.BackendABC.save","title":"<code>save(data, run_meta)</code>","text":"<p>Save a numpy array to storage.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Float64NDArray</code> <p>The numpy array to save.</p> required <code>run_meta</code> <code>RunMeta</code> <p>Metadata about the current run.</p> required Source code in <code>src/flepimop2/backend/abc/__init__.py</code> <pre><code>def save(self, data: Float64NDArray, run_meta: RunMeta) -&gt; None:\n    \"\"\"\n    Save a numpy array to storage.\n\n    Args:\n        data: The numpy array to save.\n        run_meta: Metadata about the current run.\n    \"\"\"\n    return self._save(data, run_meta)\n</code></pre>"},{"location":"reference/api/backend/#flepimop2.backend.abc.build","title":"<code>build(config)</code>","text":"<p>Build a <code>BackendABC</code> from a configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | ModuleModel</code> <p>Configuration dictionary. The dict must contains a 'module' key, which will be used to lookup the Backend module path. The module will have \"flepimop2.backend.\" prepended.</p> required <p>Returns:</p> Type Description <code>BackendABC</code> <p>The constructed backend instance.</p> Source code in <code>src/flepimop2/backend/abc/__init__.py</code> <pre><code>def build(config: dict[str, Any] | ModuleModel) -&gt; BackendABC:\n    \"\"\"Build a `BackendABC` from a configuration dictionary.\n\n    Args:\n        config: Configuration dictionary. The dict must contains a 'module' key, which\n            will be used to lookup the Backend module path. The module will have\n            \"flepimop2.backend.\" prepended.\n\n    Returns:\n        The constructed backend instance.\n\n    \"\"\"\n    return _build(config, \"backend\", \"flepimop2.backend.csv\", BackendABC)  # type: ignore[type-abstract]\n</code></pre>"},{"location":"reference/api/backend/#flepimop2.backend.csv","title":"<code>csv</code>","text":"<p>CSV backend for flepimop2.</p>"},{"location":"reference/api/backend/#flepimop2.backend.csv.CsvBackend","title":"<code>CsvBackend</code>","text":"<p>               Bases: <code>ModuleModel</code>, <code>BackendABC</code></p> <p>CSV backend for saving numpy arrays to CSV files.</p>"},{"location":"reference/api/configuration/","title":"Configuration","text":""},{"location":"reference/api/configuration/#flepimop2.configuration","title":"<code>configuration</code>","text":"<p>Representations of parsed configuration files.</p>"},{"location":"reference/api/configuration/#flepimop2.configuration.IdentifierString","title":"<code>IdentifierString = Annotated[str, Field(min_length=1, max_length=255, pattern='^[a-z]([a-z0-9\\\\_]*[a-z0-9])?$'), AfterValidator(_identifier_string)]</code>  <code>module-attribute</code>","text":"<p>A string type representing a valid identifier for named configuration elements.</p>"},{"location":"reference/api/configuration/#flepimop2.configuration.ModuleGroupModel","title":"<code>ModuleGroupModel = Annotated[dict[IdentifierString, ModuleModel], BeforeValidator(_to_default_dict)]</code>  <code>module-attribute</code>","text":"<p>Module group configuration model for flepimop2.</p>"},{"location":"reference/api/configuration/#flepimop2.configuration.ConfigurationModel","title":"<code>ConfigurationModel</code>","text":"<p>               Bases: <code>YamlSerializableBaseModel</code></p> <p>Configuration model for flepimop2.</p> <p>This model serves as the parent container for a parsed configuration file.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str | None</code> <p>An optional name for the configuration.</p> <code>engines</code> <code>ModuleGroupModel</code> <p>A dictionary of engine configurations.</p> <code>systems</code> <code>ModuleGroupModel</code> <p>A dictionary of system configurations.</p> <code>backends</code> <code>ModuleGroupModel</code> <p>A dictionary of backend configurations.</p> <code>process</code> <code>ModuleGroupModel</code> <p>A dictionary of process configurations.</p> <code>parameters</code> <code>ModuleGroupModel</code> <p>A dictionary of parameter configurations.</p> <code>simulate</code> <code>dict[IdentifierString, SimulateSpecificationModel]</code> <p>A dictionary of simulation configurations.</p>"},{"location":"reference/api/configuration/#flepimop2.configuration.ModuleModel","title":"<code>ModuleModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Module configuration model for flepimop2.</p> <p>Attributes:</p> Name Type Description <code>module</code> <code>str</code> <p>The type of the module.</p>"},{"location":"reference/api/configuration/#flepimop2.configuration.SimulateSpecificationModel","title":"<code>SimulateSpecificationModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for specifying a simulation for flepimop2.</p> <p>Attributes:</p> Name Type Description <code>engine</code> <code>IdentifierString</code> <p>The name of the engine to use for the simulation.</p> <code>system</code> <code>IdentifierString</code> <p>The name of the system to simulate.</p> <code>backend</code> <code>IdentifierString</code> <p>The name of the backend to use for the simulation.</p> <code>times</code> <code>RangeSpec</code> <p>A list of time points at which to perform the simulation.</p> <code>params</code> <code>dict[str, float] | None</code> <p>Optional dictionary of parameters for the simulation.</p>"},{"location":"reference/api/configuration/#flepimop2.configuration.SimulateSpecificationModel.t_eval","title":"<code>t_eval</code>  <code>property</code>","text":"<p>Get the evaluation times as a NumPy array.</p> <p>Returns:</p> Type Description <code>Float64NDArray</code> <p>A NumPy array of evaluation times.</p>"},{"location":"reference/api/engine/","title":"Engine","text":""},{"location":"reference/api/engine/#flepimop2.engine.abc","title":"<code>abc</code>","text":"<p>Abstract class for Engines to evolve Dynamic Systems.</p>"},{"location":"reference/api/engine/#flepimop2.engine.abc.EngineABC","title":"<code>EngineABC(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModuleABC</code></p> <p>Abstract class for Engines to evolve Dynamic Systems.</p> <p>Initialize the EngineABC.</p> <p>The default initialization sets the runner to a no-op function. Concrete implementations should override this with a valid runner function.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments.</p> <code>{}</code> Source code in <code>src/flepimop2/engine/abc/__init__.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ARG002\n    \"\"\"\n    Initialize the EngineABC.\n\n    The default initialization sets the runner to a no-op function. Concrete\n    implementations should override this with a valid runner function.\n\n    Args:\n        *args: Positional arguments.\n        **kwargs: Keyword arguments.\n    \"\"\"\n    self._runner = _no_run_func\n</code></pre>"},{"location":"reference/api/engine/#flepimop2.engine.abc.EngineABC.run","title":"<code>run(system, eval_times, initial_state, params, **kwargs)</code>","text":"<p>Run the engine with the provided system and parameters.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>SystemABC</code> <p>The dynamic system to be evolved.</p> required <code>eval_times</code> <code>Float64NDArray</code> <p>Array of time points for evaluation.</p> required <code>initial_state</code> <code>Float64NDArray</code> <p>The initial state array.</p> required <code>params</code> <code>dict[IdentifierString, Any]</code> <p>Additional parameters for the stepper.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for the engine.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Float64NDArray</code> <p>The evolved time x state array.</p> Source code in <code>src/flepimop2/engine/abc/__init__.py</code> <pre><code>def run(\n    self,\n    system: SystemABC,\n    eval_times: Float64NDArray,\n    initial_state: Float64NDArray,\n    params: dict[IdentifierString, Any],\n    **kwargs: Any,\n) -&gt; Float64NDArray:\n    \"\"\"\n    Run the engine with the provided system and parameters.\n\n    Args:\n        system: The dynamic system to be evolved.\n        eval_times: Array of time points for evaluation.\n        initial_state: The initial state array.\n        params: Additional parameters for the stepper.\n        **kwargs: Additional keyword arguments for the engine.\n\n    Returns:\n        The evolved time x state array.\n    \"\"\"\n    return self._runner(\n        system._stepper,  # noqa: SLF001\n        eval_times,\n        initial_state,\n        params,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/api/engine/#flepimop2.engine.abc.EngineABC.validate_system","title":"<code>validate_system(system)</code>","text":"<p>Validation hook for system properties.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>SystemABC</code> <p>The system to validate.</p> required <p>Returns:</p> Type Description <code>list[ValidationIssue] | None</code> <p>A list of validation issues, or <code>None</code> if not implemented.</p> Source code in <code>src/flepimop2/engine/abc/__init__.py</code> <pre><code>def validate_system(  # noqa: PLR6301\n    self,\n    system: SystemABC,  # noqa: ARG002\n) -&gt; list[ValidationIssue] | None:\n    \"\"\"\n    Validation hook for system properties.\n\n    Args:\n        system: The system to validate.\n\n    Returns:\n        A list of validation issues, or `None` if not implemented.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/api/engine/#flepimop2.engine.abc.EngineProtocol","title":"<code>EngineProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Type-definition (Protocol) for engine runner functions.</p>"},{"location":"reference/api/engine/#flepimop2.engine.abc.EngineProtocol.__call__","title":"<code>__call__(stepper, times, state, params, **kwargs)</code>","text":"<p>Protocol for engine runner functions.</p> Source code in <code>src/flepimop2/engine/abc/__init__.py</code> <pre><code>def __call__(\n    self,\n    stepper: SystemProtocol,\n    times: Float64NDArray,\n    state: Float64NDArray,\n    params: dict[IdentifierString, Any],\n    **kwargs: Any,\n) -&gt; Float64NDArray:\n    \"\"\"Protocol for engine runner functions.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/api/engine/#flepimop2.engine.abc.build","title":"<code>build(config)</code>","text":"<p>Build a <code>EngineABC</code> from a configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | ModuleModel</code> <p>Configuration dictionary or a <code>ModuleModel</code> instance to construct the engine from.</p> required <p>Returns:</p> Type Description <code>EngineABC</code> <p>The constructed engine instance.</p> Source code in <code>src/flepimop2/engine/abc/__init__.py</code> <pre><code>def build(config: dict[str, Any] | ModuleModel) -&gt; EngineABC:\n    \"\"\"Build a `EngineABC` from a configuration dictionary.\n\n    Args:\n        config: Configuration dictionary or a `ModuleModel` instance to construct the\n            engine from.\n\n    Returns:\n        The constructed engine instance.\n\n    \"\"\"\n    return _build(config, \"engine\", \"flepimop2.engine.wrapper\", EngineABC)\n</code></pre>"},{"location":"reference/api/engine/#flepimop2.engine.wrapper","title":"<code>wrapper</code>","text":"<p>A <code>EngineABC</code> which wraps a user-defined script file.</p>"},{"location":"reference/api/engine/#flepimop2.engine.wrapper.WrapperEngine","title":"<code>WrapperEngine(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModuleModel</code>, <code>EngineABC</code></p> <p>A <code>EngineABC</code> which wraps a user-defined script file.</p> Source code in <code>src/flepimop2/engine/abc/__init__.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ARG002\n    \"\"\"\n    Initialize the EngineABC.\n\n    The default initialization sets the runner to a no-op function. Concrete\n    implementations should override this with a valid runner function.\n\n    Args:\n        *args: Positional arguments.\n        **kwargs: Keyword arguments.\n    \"\"\"\n    self._runner = _no_run_func\n</code></pre>"},{"location":"reference/api/engine/#flepimop2.engine.wrapper.WrapperEngine.validate_system","title":"<code>validate_system(system)</code>","text":"<p>Validate that the given system is compatible with this engine.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>SystemABC</code> <p>The system to validate.</p> required <p>Returns:</p> Type Description <code>list[ValidationIssue] | None</code> <p>A list of validation issues, or <code>None</code> if not implemented.</p> Source code in <code>src/flepimop2/engine/wrapper/__init__.py</code> <pre><code>def validate_system(self, system: SystemABC) -&gt; list[ValidationIssue] | None:\n    \"\"\"\n    Validate that the given system is compatible with this engine.\n\n    Args:\n        system: The system to validate.\n\n    Returns:\n        A list of validation issues, or `None` if not implemented.\n\n    \"\"\"\n    if system.state_change != self.state_change:\n        return [\n            ValidationIssue(\n                msg=(\n                    f\"Engine state change type, '{self.state_change}', is not \"\n                    \"compatible with system state change type \"\n                    f\"'{system.state_change}'.\"\n                ),\n                kind=\"incompatible_system\",\n            )\n        ]\n    return None\n</code></pre>"},{"location":"reference/api/exceptions/","title":"Exceptions","text":""},{"location":"reference/api/exceptions/#flepimop2.exceptions","title":"<code>exceptions</code>","text":"<p>Custom exceptions provided by the <code>flepimop2</code> package.</p>"},{"location":"reference/api/exceptions/#flepimop2.exceptions.Flepimop2Error","title":"<code>Flepimop2Error</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for exceptions provided by <code>flepimop2</code>.</p> <p>This class serves as the root for all custom exceptions in the <code>flepimop2</code> library.</p>"},{"location":"reference/api/exceptions/#flepimop2.exceptions.Flepimop2ValidationError","title":"<code>Flepimop2ValidationError(issues)</code>","text":"<p>               Bases: <code>Flepimop2Error</code></p> <p>Exception raised for validation errors from <code>flepimop2</code>.</p> <p>This exception's main purpose is to signal that validation has failed within the <code>flepimop2</code> library and provides detailed information about the validation issues encountered, typically provided by an external provider package. The main benefit of this exception is to encapsulate multiple validation issues into a single error object, making it easier to handle and report validation failures as well as providing a consistent interface for validation errors across different parts of the <code>flepimop2</code> library.</p> <p>Attributes:</p> Name Type Description <code>issues</code> <p>A list of <code>ValidationIssue</code> instances representing the validation errors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; from flepimop2.exceptions import (\n...     Flepimop2ValidationError,\n...     ValidationIssue,\n... )\n&gt;&gt;&gt; issues = [\n...     ValidationIssue(\n...         msg=\"Model requires undefined parameter 'gamma'.\",\n...         kind=\"missing_parameter\",\n...         ctx={\"parameter\": \"gamma\", \"transition\": \"gamma * (S / N)\"},\n...     ),\n...     ValidationIssue(\n...         msg=\"Compartment 'E' is unreachable.\",\n...         kind=\"unreachable_compartment\",\n...         ctx={\"compartment\": \"E\"},\n...     ),\n... ]\n&gt;&gt;&gt; exception = Flepimop2ValidationError(issues)\n&gt;&gt;&gt; pprint(exception.issues)\n[ValidationIssue(msg=\"Model requires undefined parameter 'gamma'.\",\n                 kind='missing_parameter',\n                 ctx={'parameter': 'gamma', 'transition': 'gamma * (S / N)'}),\n ValidationIssue(msg=\"Compartment 'E' is unreachable.\",\n                 kind='unreachable_compartment',\n                 ctx={'compartment': 'E'})]\n&gt;&gt;&gt; print(exception)\n2 validation issues encountered:\n- [missing_parameter] Model requires undefined parameter 'gamma'. (parameter=gamma, transition=gamma * (S / N))\n- [unreachable_compartment] Compartment 'E' is unreachable. (compartment=E)\n&gt;&gt;&gt; raise Flepimop2ValidationError(issues)\nTraceback (most recent call last):\n    ...\nflepimop2.exceptions._flepimop2_validation_error.Flepimop2ValidationError: 2 validation issues encountered:\n- [missing_parameter] Model requires undefined parameter 'gamma'. (parameter=gamma, transition=gamma * (S / N))\n- [unreachable_compartment] Compartment 'E' is unreachable. (compartment=E)\n</code></pre> <p>Initialize the Flepimop2ValidationError.</p> <p>Parameters:</p> Name Type Description Default <code>issues</code> <code>list[ValidationIssue]</code> <p>A list of <code>ValidationIssue</code> instances representing the validation errors.</p> required Source code in <code>src/flepimop2/exceptions/_flepimop2_validation_error.py</code> <pre><code>def __init__(self, issues: list[ValidationIssue]) -&gt; None:\n    \"\"\"\n    Initialize the Flepimop2ValidationError.\n\n    Args:\n        issues: A list of `ValidationIssue` instances representing the validation\n            errors.\n    \"\"\"\n    self.issues = issues\n    message = self._format_issues(issues)\n    super().__init__(message)\n</code></pre>"},{"location":"reference/api/exceptions/#flepimop2.exceptions.ValidationIssue","title":"<code>ValidationIssue(msg, kind, ctx=None)</code>  <code>dataclass</code>","text":"<p>Represents a single validation issue encountered during data validation.</p> <p>Attributes:</p> Name Type Description <code>msg</code> <code>str</code> <p>A human readable description of the validation issue.</p> <code>kind</code> <code>str</code> <p>The type/category of the validation issue.</p> <code>ctx</code> <code>dict[str, Any] | None</code> <p>Optional context providing additional information about the issue.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; from flepimop2.exceptions import ValidationIssue\n&gt;&gt;&gt; issue = ValidationIssue(\n...     msg=\"Invalid wrapper data format.\",\n...     kind=\"invalid_format\",\n...     ctx={\"expected_format\": \"JSON\", \"line\": 42},\n... )\n&gt;&gt;&gt; pprint(issue)\nValidationIssue(msg='Invalid wrapper data format.',\n                kind='invalid_format',\n                ctx={'expected_format': 'JSON', 'line': 42})\n</code></pre>"},{"location":"reference/api/meta/","title":"Meta","text":""},{"location":"reference/api/meta/#flepimop2.meta","title":"<code>meta</code>","text":"<p>Metadata types for flepimop2 runs.</p>"},{"location":"reference/api/meta/#flepimop2.meta.RunMeta","title":"<code>RunMeta</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Metadata for a flepimop2 run.</p> <p>Attributes:</p> Name Type Description <code>action</code> <code>Literal['simulate']</code> <p>The action performed in the run (e.g., \"simulate\").</p> <code>timestamp</code> <code>datetime</code> <p>The timestamp when the run was executed. Defaults to current UTC time.</p> <code>name</code> <code>str | None</code> <p>An optional name for the run, typically pulled from the config.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flepimop2.meta import RunMeta\n&gt;&gt;&gt; run_meta = RunMeta(name=\"test_run\")\n&gt;&gt;&gt; run_meta.action\n'simulate'\n&gt;&gt;&gt; run_meta.timestamp\ndatetime.datetime(..., tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt; run_meta.name\n'test_run'\n</code></pre>"},{"location":"reference/api/module/","title":"Module","text":""},{"location":"reference/api/module/#flepimop2.module","title":"<code>module</code>","text":"<p>Base class for defining modules in the system, engine, or backend.</p>"},{"location":"reference/api/module/#flepimop2.module.ModuleABC","title":"<code>ModuleABC</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for modules in the system, engine, or backend.</p> <p>Attributes:</p> Name Type Description <code>module</code> <code>str</code> <p>The name of the module.</p> <code>options</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of additional options the module exposes for <code>flepimop2</code> to take advantage of.</p>"},{"location":"reference/api/module/#flepimop2.module.ModuleABC.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"<p>Ensure concrete subclasses define a valid module name.</p> <p>This validation works for both plain Python and Pydantic-based subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to parent classes.</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If a concrete subclass does not define a valid <code>module</code> string.</p> Source code in <code>src/flepimop2/module.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Ensure concrete subclasses define a valid module name.\n\n    This validation works for both plain Python and Pydantic-based subclasses.\n\n    Args:\n        **kwargs: Additional keyword arguments passed to parent classes.\n\n    Raises:\n        TypeError: If a concrete subclass does not define a valid `module` string.\n\n    \"\"\"\n    super().__init_subclass__(**kwargs)\n    if inspect.isabstract(cls) or cls.__name__.endswith(\"ABC\"):\n        return\n    module = cls.__dict__.get(\"module\")\n    if not isinstance(module, str) or not module:\n        msg = (\n            f\"Concrete class '{cls.__name__}' must define class attribute \"\n            \"'module' as a non-empty string.\"\n        )\n        raise TypeError(msg)\n</code></pre>"},{"location":"reference/api/module/#flepimop2.module.ModuleABC.option","title":"<code>option(name, default=RaiseOnMissing)</code>","text":"<p>Retrieve an option value by name, with an optional default.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the option to retrieve.</p> required <code>default</code> <code>Any</code> <p>The default value to return if the option is not found. If not provided, defaults to <code>RaiseOnMissing</code>, which will cause a <code>KeyError</code> to be raised if the option is missing.</p> <code>RaiseOnMissing</code> <p>Returns:</p> Type Description <code>Any</code> <p>The value of the option if found, otherwise the default value.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the option is missing and <code>default</code> is not provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flepimop2.module import ModuleABC\n&gt;&gt;&gt; class MyModule(ModuleABC):\n...     module = \"my_module\"\n...     options = {\"option1\": 42}\n&gt;&gt;&gt; mod = MyModule()\n&gt;&gt;&gt; mod.option(\"option1\")\n42\n&gt;&gt;&gt; mod.option(\"option2\", default=\"default_value\")\n'default_value'\n&gt;&gt;&gt; mod.option(\"option2\")\nTraceback (most recent call last):\n    ...\nKeyError: \"Option 'option2' not found in module 'my_module'.\"\n&gt;&gt;&gt; class MyModuleWithMissingOption(ModuleABC):\n...     module = \"missing_opts\"\n&gt;&gt;&gt; mod = MyModuleWithMissingOption()\n&gt;&gt;&gt; mod.option(\"option1\", default=\"default_value\")\n'default_value'\n&gt;&gt;&gt; mod.option(\"option1\")\nTraceback (most recent call last):\n    ...\nKeyError: \"Option 'option1' not found in module 'missing_opts'.\"\n</code></pre> Source code in <code>src/flepimop2/module.py</code> <pre><code>def option(self, name: str, default: Any = RaiseOnMissing) -&gt; Any:  # noqa: ANN401\n    \"\"\"\n    Retrieve an option value by name, with an optional default.\n\n    Args:\n        name: The name of the option to retrieve.\n        default: The default value to return if the option is not found. If\n            not provided, defaults to `RaiseOnMissing`, which will cause a\n            `KeyError` to be raised if the option is missing.\n\n    Returns:\n        The value of the option if found, otherwise the default value.\n\n    Raises:\n        KeyError: If the option is missing and `default` is not provided.\n\n    Examples:\n        &gt;&gt;&gt; from flepimop2.module import ModuleABC\n        &gt;&gt;&gt; class MyModule(ModuleABC):\n        ...     module = \"my_module\"\n        ...     options = {\"option1\": 42}\n        &gt;&gt;&gt; mod = MyModule()\n        &gt;&gt;&gt; mod.option(\"option1\")\n        42\n        &gt;&gt;&gt; mod.option(\"option2\", default=\"default_value\")\n        'default_value'\n        &gt;&gt;&gt; mod.option(\"option2\")\n        Traceback (most recent call last):\n            ...\n        KeyError: \"Option 'option2' not found in module 'my_module'.\"\n        &gt;&gt;&gt; class MyModuleWithMissingOption(ModuleABC):\n        ...     module = \"missing_opts\"\n        &gt;&gt;&gt; mod = MyModuleWithMissingOption()\n        &gt;&gt;&gt; mod.option(\"option1\", default=\"default_value\")\n        'default_value'\n        &gt;&gt;&gt; mod.option(\"option1\")\n        Traceback (most recent call last):\n            ...\n        KeyError: \"Option 'option1' not found in module 'missing_opts'.\"\n\n    \"\"\"\n    opts = self.options or {}\n    if name not in opts and isinstance(default, RaiseOnMissingType):\n        msg = f\"Option '{name}' not found in module '{self.module}'.\"\n        raise KeyError(msg)\n    return opts.get(name, default)\n</code></pre>"},{"location":"reference/api/parameter/","title":"Parameter","text":""},{"location":"reference/api/parameter/#flepimop2.parameter.abc","title":"<code>abc</code>","text":"<p>Abstract base class for parameters.</p>"},{"location":"reference/api/parameter/#flepimop2.parameter.abc.ParameterABC","title":"<code>ParameterABC</code>","text":"<p>               Bases: <code>ModuleABC</code></p> <p>Abstract base class for parameters.</p>"},{"location":"reference/api/parameter/#flepimop2.parameter.abc.ParameterABC.sample","title":"<code>sample()</code>  <code>abstractmethod</code>","text":"<p>Sample a value from the parameter.</p> <p>Returns:</p> Type Description <code>Float64NDArray</code> <p>A sampled value from the parameter.</p> Source code in <code>src/flepimop2/parameter/abc/__init__.py</code> <pre><code>@abstractmethod\ndef sample(self) -&gt; Float64NDArray:\n    \"\"\"Sample a value from the parameter.\n\n    Returns:\n        A sampled value from the parameter.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/api/parameter/#flepimop2.parameter.abc.build","title":"<code>build(config)</code>","text":"<p>Build a <code>ParameterABC</code> from a configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | ModuleModel</code> <p>Configuration dictionary or a <code>ModuleModel</code> instance to construct the parameter from.</p> required <p>Returns:</p> Type Description <code>ParameterABC</code> <p>The constructed parameter instance.</p> Source code in <code>src/flepimop2/parameter/abc/__init__.py</code> <pre><code>def build(config: dict[str, Any] | ModuleModel) -&gt; ParameterABC:\n    \"\"\"Build a `ParameterABC` from a configuration dictionary.\n\n    Args:\n        config: Configuration dictionary or a `ModuleModel` instance to construct the\n            parameter from.\n\n    Returns:\n        The constructed parameter instance.\n\n    \"\"\"\n    return _build(config, \"parameter\", \"flepimop2.parameter.wrapper\", ParameterABC)  # type: ignore[type-abstract]\n</code></pre>"},{"location":"reference/api/parameter/#flepimop2.parameter.fixed","title":"<code>fixed</code>","text":"<p>Fixed parameter implementation.</p>"},{"location":"reference/api/parameter/#flepimop2.parameter.fixed.FixedParameter","title":"<code>FixedParameter</code>","text":"<p>               Bases: <code>ModuleModel</code>, <code>ParameterABC</code></p> <p>Parameter with a fixed value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flepimop2.parameter.fixed import FixedParameter\n&gt;&gt;&gt; param = FixedParameter(value=42.0)\n&gt;&gt;&gt; param.sample()\narray([42.])\n</code></pre>"},{"location":"reference/api/parameter/#flepimop2.parameter.fixed.FixedParameter.sample","title":"<code>sample()</code>","text":"<p>Return the fixed value of the parameter.</p> <p>Returns:</p> Type Description <code>Float64NDArray</code> <p>The fixed numeric value of the parameter.</p> Source code in <code>src/flepimop2/parameter/fixed/__init__.py</code> <pre><code>def sample(self) -&gt; Float64NDArray:\n    \"\"\"\n    Return the fixed value of the parameter.\n\n    Returns:\n        The fixed numeric value of the parameter.\n    \"\"\"\n    return np.array([self.value], dtype=np.float64)\n</code></pre>"},{"location":"reference/api/process/","title":"Process","text":""},{"location":"reference/api/process/#flepimop2.process.abc","title":"<code>abc</code>","text":"<p>Abstract base class for flepimop2 processing steps.</p>"},{"location":"reference/api/process/#flepimop2.process.abc.ProcessABC","title":"<code>ProcessABC</code>","text":"<p>               Bases: <code>ModuleABC</code></p> <p>Abstract base class for flepimop2 processing steps.</p>"},{"location":"reference/api/process/#flepimop2.process.abc.ProcessABC.execute","title":"<code>execute(*, dry_run=False)</code>","text":"<p>Execute a processing step.</p> <p>Parameters:</p> Name Type Description Default <code>dry_run</code> <code>bool</code> <p>If True, the process will not actually execute but will simulate execution.</p> <code>False</code> <p>Raises:</p> Type Description <code>Flepimop2ValidationError</code> <p>If validation fails during a dry run.</p> Source code in <code>src/flepimop2/process/abc/__init__.py</code> <pre><code>def execute(self, *, dry_run: bool = False) -&gt; None:\n    \"\"\"\n    Execute a processing step.\n\n    Args:\n        dry_run: If True, the process will not actually execute but will simulate\n            execution.\n\n    Raises:\n        Flepimop2ValidationError: If validation fails during a dry run.\n    \"\"\"\n    if dry_run and (result := self._process_validate()) is not None:\n        if result:\n            raise Flepimop2ValidationError(result)\n        return None\n    return self._process(dry_run=dry_run)\n</code></pre>"},{"location":"reference/api/process/#flepimop2.process.abc.build","title":"<code>build(config)</code>","text":"<p>Build a <code>ProcessABC</code> from a configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | ModuleModel</code> <p>Configuration dictionary. The dict should contain a 'module' key, which will be used to lookup the Process module path. The module will have \"flepimop2.process.\" prepended.</p> required <p>Returns:</p> Name Type Description <code>ProcessABC</code> <code>ProcessABC</code> <p>The constructed process object.</p> Source code in <code>src/flepimop2/process/abc/__init__.py</code> <pre><code>def build(config: dict[str, Any] | ModuleModel) -&gt; ProcessABC:\n    \"\"\"Build a `ProcessABC` from a configuration dictionary.\n\n    Args:\n        config: Configuration dictionary. The dict should contain a\n            'module' key, which will be used to lookup the Process module path.\n            The module will have \"flepimop2.process.\" prepended.\n\n    Returns:\n        ProcessABC: The constructed process object.\n\n    \"\"\"\n    return _build(config, \"process\", \"flepimop2.process.shell\", ProcessABC)  # type: ignore[type-abstract]\n</code></pre>"},{"location":"reference/api/process/#flepimop2.process.shell","title":"<code>shell</code>","text":"<p>Shell process for flepimop2.</p>"},{"location":"reference/api/process/#flepimop2.process.shell.ShellProcess","title":"<code>ShellProcess</code>","text":"<p>               Bases: <code>ModuleModel</code>, <code>ProcessABC</code></p> <p>Shell process for executing commands.</p> <p>Attributes:</p> Name Type Description <code>module</code> <code>Literal['flepimop2.process.shell']</code> <p>The module type, fixed to \"flepimop2.process.shell\".</p> <code>command</code> <code>str</code> <p>The shell command to execute.</p> <code>args</code> <code>list[str]</code> <p>Arguments to pass to the shell command.</p>"},{"location":"reference/api/simulator/","title":"Simulator","text":""},{"location":"reference/api/simulator/#flepimop2.simulator","title":"<code>simulator</code>","text":"<p>Simulation orchestration for flepimop2.</p>"},{"location":"reference/api/simulator/#flepimop2.simulator.Simulator","title":"<code>Simulator(system, engine, backend, *, target=None, simulate_config=None, system_config=None, engine_config=None, backend_config=None)</code>","text":"<p>Build and run a single simulation from configuration models.</p> <p>Attributes:</p> Name Type Description <code>system</code> <code>SystemABC</code> <p>The built system instance.</p> <code>engine</code> <code>EngineABC</code> <p>The built engine instance.</p> <code>backend</code> <code>BackendABC</code> <p>The built backend instance.</p> <code>target</code> <code>str | None</code> <p>Optional target simulate config to use.</p> <code>simulate_config</code> <code>SimulateSpecificationModel | None</code> <p>The resolved simulation specification.</p> <code>system_config</code> <code>ModuleModel | None</code> <p>The resolved system configuration dict.</p> <code>engine_config</code> <code>ModuleModel | None</code> <p>The resolved engine configuration dict.</p> <code>backend_config</code> <code>ModuleModel | None</code> <p>The resolved backend configuration dict.</p> <p>Initialize the simulator with resolved components.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>SystemABC</code> <p>The built system instance.</p> required <code>engine</code> <code>EngineABC</code> <p>The built engine instance.</p> required <code>backend</code> <code>BackendABC</code> <p>The built backend instance.</p> required <code>target</code> <code>str | None</code> <p>Optional target simulate config to use.</p> <code>None</code> <code>simulate_config</code> <code>SimulateSpecificationModel | None</code> <p>The resolved simulation specification, if available.</p> <code>None</code> <code>system_config</code> <code>ModuleModel | None</code> <p>The resolved system configuration model, if available.</p> <code>None</code> <code>engine_config</code> <code>ModuleModel | None</code> <p>The resolved engine configuration model, if available.</p> <code>None</code> <code>backend_config</code> <code>ModuleModel | None</code> <p>The resolved backend configuration model, if available.</p> <code>None</code> <p>Raises:</p> Type Description <code>Flepimop2ValidationError</code> <p>If the engine is incompatible with the system.</p> Source code in <code>src/flepimop2/simulator.py</code> <pre><code>def __init__(  # noqa: PLR0913\n    self,\n    system: SystemABC,\n    engine: EngineABC,\n    backend: BackendABC,\n    *,\n    target: str | None = None,\n    simulate_config: SimulateSpecificationModel | None = None,\n    system_config: ModuleModel | None = None,\n    engine_config: ModuleModel | None = None,\n    backend_config: ModuleModel | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the simulator with resolved components.\n\n    Args:\n        system: The built system instance.\n        engine: The built engine instance.\n        backend: The built backend instance.\n        target: Optional target simulate config to use.\n        simulate_config: The resolved simulation specification, if available.\n        system_config: The resolved system configuration model, if available.\n        engine_config: The resolved engine configuration model, if available.\n        backend_config: The resolved backend configuration model, if available.\n\n    Raises:\n        Flepimop2ValidationError: If the engine is incompatible with the system.\n\n    \"\"\"\n    self.target = target\n    self.simulate_config = simulate_config\n    self.system_config = system_config\n    self.engine_config = engine_config\n    self.backend_config = backend_config\n    self.system = system\n    self.engine = engine\n    self.backend = backend\n\n    if issues := self.engine.validate_system(self.system):\n        raise Flepimop2ValidationError(issues)\n</code></pre>"},{"location":"reference/api/simulator/#flepimop2.simulator.Simulator.from_configuration_model","title":"<code>from_configuration_model(config_model, target=None)</code>  <code>classmethod</code>","text":"<p>Build a simulator from a configuration model.</p> <p>Returns:</p> Type Description <code>Simulator</code> <p>The constructed simulator instance.</p> Source code in <code>src/flepimop2/simulator.py</code> <pre><code>@classmethod\ndef from_configuration_model(\n    cls,\n    config_model: ConfigurationModel,\n    target: str | None = None,\n) -&gt; \"Simulator\":\n    \"\"\"\n    Build a simulator from a configuration model.\n\n    Returns:\n        The constructed simulator instance.\n\n    \"\"\"\n    simulate_config = _get_config_target(\n        config_model.simulate,\n        target,\n        \"simulate\",\n    )\n\n    system_config = config_model.systems[simulate_config.system]\n    engine_config = config_model.engines[simulate_config.engine]\n    backend_config = config_model.backends[simulate_config.backend]\n\n    system = build_system(system_config)\n    engine = build_engine(engine_config)\n    backend = build_backend(backend_config)\n\n    return cls(\n        system,\n        engine,\n        backend,\n        target=target,\n        simulate_config=simulate_config,\n        system_config=system_config,\n        engine_config=engine_config,\n        backend_config=backend_config,\n    )\n</code></pre>"},{"location":"reference/api/simulator/#flepimop2.simulator.Simulator.run","title":"<code>run(initial_state, params)</code>","text":"<p>Run the simulation and persist results via the backend.</p> <p>Returns:</p> Type Description <code>Float64NDArray</code> <p>The simulation result array.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>simulate_config</code> is not set.</p> Source code in <code>src/flepimop2/simulator.py</code> <pre><code>def run(\n    self,\n    initial_state: Float64NDArray,\n    params: dict[str, float],\n) -&gt; Float64NDArray:\n    \"\"\"\n    Run the simulation and persist results via the backend.\n\n    Returns:\n        The simulation result array.\n\n    Raises:\n        ValueError: If `simulate_config` is not set.\n\n    \"\"\"\n    if self.simulate_config is None:\n        msg = \"simulate_config must be set before running the simulator.\"\n        raise ValueError(msg)\n    res = self.engine.run(\n        self.system,\n        self.simulate_config.t_eval,\n        initial_state,\n        params,\n    )\n    self.backend.save(res, RunMeta())\n    return res\n</code></pre>"},{"location":"reference/api/system/","title":"System","text":""},{"location":"reference/api/system/#flepimop2.system.abc","title":"<code>abc</code>","text":"<p>Abstract class for Dynamic Systems.</p>"},{"location":"reference/api/system/#flepimop2.system.abc.SystemABC","title":"<code>SystemABC(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModuleABC</code></p> <p>Abstract class for Dynamic Systems.</p> <p>Attributes:</p> Name Type Description <code>module</code> <code>str</code> <p>The module name for the system.</p> <code>state_change</code> <code>StateChangeEnum</code> <p>The type of state change.</p> <code>options</code> <code>dict[str, Any] | None</code> <p>Optional dictionary of additional options the system exposes for <code>flepimop2</code> to take advantage of.</p> <p>Initialize the SystemABC.</p> <p>The default initialization sets the stepper to a no-op function. Concrete implementations should override this with a valid stepper function.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments.</p> <code>{}</code> Source code in <code>src/flepimop2/system/abc/__init__.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ARG002\n    \"\"\"\n    Initialize the SystemABC.\n\n    The default initialization sets the stepper to a no-op function. Concrete\n    implementations should override this with a valid stepper function.\n\n    Args:\n        *args: Positional arguments.\n        **kwargs: Keyword arguments.\n    \"\"\"\n    self._stepper = _no_step_function\n</code></pre>"},{"location":"reference/api/system/#flepimop2.system.abc.SystemABC.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"<p>Ensure concrete subclasses define a valid state change type.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments passed to parent classes.</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If a concrete subclass does not define <code>state_change</code>.</p> Source code in <code>src/flepimop2/system/abc/__init__.py</code> <pre><code>def __init_subclass__(cls, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Ensure concrete subclasses define a valid state change type.\n\n    Args:\n        **kwargs: Additional keyword arguments passed to parent classes.\n\n    Raises:\n        TypeError: If a concrete subclass does not define `state_change`.\n\n    \"\"\"\n    super().__init_subclass__(**kwargs)\n    if inspect.isabstract(cls):\n        return\n    annotations = inspect.get_annotations(cls)\n    has_state_change = (\n        \"state_change\" in cls.__dict__ or \"state_change\" in annotations\n    )\n    if not has_state_change:\n        msg = (\n            f\"Concrete class '{cls.__name__}' must define 'state_change' as \"\n            \"a class attribute or type annotation.\"\n        )\n        raise TypeError(msg)\n</code></pre>"},{"location":"reference/api/system/#flepimop2.system.abc.SystemABC.step","title":"<code>step(time, state, **params)</code>","text":"<p>Perform a single step of the system's dynamics.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float64</code> <p>The current time.</p> required <code>state</code> <code>Float64NDArray</code> <p>The current state array.</p> required <code>**params</code> <code>Any</code> <p>Additional parameters for the stepper.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Float64NDArray</code> <p>The next state array after one step.</p> Source code in <code>src/flepimop2/system/abc/__init__.py</code> <pre><code>def step(\n    self, time: np.float64, state: Float64NDArray, **params: Any\n) -&gt; Float64NDArray:\n    \"\"\"\n    Perform a single step of the system's dynamics.\n\n    Args:\n        time: The current time.\n        state: The current state array.\n        **params: Additional parameters for the stepper.\n\n    Returns:\n        The next state array after one step.\n    \"\"\"\n    return self._stepper(time, state, **params)\n</code></pre>"},{"location":"reference/api/system/#flepimop2.system.abc.SystemProtocol","title":"<code>SystemProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Type-definition (Protocol) for system stepper functions.</p>"},{"location":"reference/api/system/#flepimop2.system.abc.SystemProtocol.__call__","title":"<code>__call__(time, state, **kwargs)</code>","text":"<p>Protocol for system stepper functions.</p> Source code in <code>src/flepimop2/system/abc/__init__.py</code> <pre><code>def __call__(\n    self, time: np.float64, state: Float64NDArray, **kwargs: Any\n) -&gt; Float64NDArray:\n    \"\"\"Protocol for system stepper functions.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/api/system/#flepimop2.system.abc.build","title":"<code>build(config)</code>","text":"<p>Build a <code>SystemABC</code> from a configuration dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | ModuleModel</code> <p>Configuration dictionary or a <code>ModuleModel</code> instance.</p> required <p>Returns:</p> Type Description <code>SystemABC</code> <p>The constructed system instance.</p> Source code in <code>src/flepimop2/system/abc/__init__.py</code> <pre><code>def build(config: dict[str, Any] | ModuleModel) -&gt; SystemABC:\n    \"\"\"\n    Build a `SystemABC` from a configuration dictionary.\n\n    Args:\n        config: Configuration dictionary or a `ModuleModel` instance.\n\n    Returns:\n        The constructed system instance.\n\n    \"\"\"\n    return _build(\n        config,\n        \"system\",\n        \"flepimop2.system.wrapper\",\n        SystemABC,\n    )\n</code></pre>"},{"location":"reference/api/system/#flepimop2.system.wrapper","title":"<code>wrapper</code>","text":"<p>A <code>SystemABC</code> which wraps a user-defined script file.</p>"},{"location":"reference/api/system/#flepimop2.system.wrapper.WrapperSystem","title":"<code>WrapperSystem(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModuleModel</code>, <code>SystemABC</code></p> <p>A <code>SystemABC</code> which wraps a user-defined script file.</p> Source code in <code>src/flepimop2/system/abc/__init__.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:  # noqa: ARG002\n    \"\"\"\n    Initialize the SystemABC.\n\n    The default initialization sets the stepper to a no-op function. Concrete\n    implementations should override this with a valid stepper function.\n\n    Args:\n        *args: Positional arguments.\n        **kwargs: Keyword arguments.\n    \"\"\"\n    self._stepper = _no_step_function\n</code></pre>"},{"location":"reference/api/testing/","title":"Testing","text":""},{"location":"reference/api/testing/#flepimop2.testing","title":"<code>testing</code>","text":"<p>Public testing utilities for <code>flepimop2</code>.</p>"},{"location":"reference/api/testing/#flepimop2.testing.external_provider_package","title":"<code>external_provider_package(parent_directory, copy_files=None, dependencies=None, project_name='example-provider', project_requires_python='&gt;=3.11')</code>","text":"<p>Set up an external provider package and install it into a fresh venv.</p> <p>Parameters:</p> Name Type Description Default <code>parent_directory</code> <code>Path</code> <p>Directory in which to set up the provider package and venv.</p> required <code>copy_files</code> <code>dict[Path, Path] | None</code> <p>Optional mapping of source files to destination paths within <code>parent_directory</code>.</p> <code>None</code> <code>dependencies</code> <code>list[str] | None</code> <p>Optional list of dependencies to include in the provider package. If omitted, defaults to <code>[\"flepimop2\"]</code>.</p> <code>None</code> <code>project_name</code> <code>str</code> <p>Optional name for the provider package. Defaults to \"example-provider\".</p> <code>'example-provider'</code> <code>project_requires_python</code> <code>str</code> <p>Optional Python version specifier for the provider package. Defaults to \"&gt;=3.11\".</p> <code>'&gt;=3.11'</code> <p>Returns:</p> Type Description <code>str</code> <p>The python executable path from the newly created venv.</p> Source code in <code>src/flepimop2/testing.py</code> <pre><code>def external_provider_package(\n    parent_directory: Path,\n    copy_files: dict[Path, Path] | None = None,\n    dependencies: list[str] | None = None,\n    project_name: str = \"example-provider\",\n    project_requires_python: str = \"&gt;=3.11\",\n) -&gt; str:\n    \"\"\"\n    Set up an external provider package and install it into a fresh venv.\n\n    Args:\n        parent_directory: Directory in which to set up the provider package and venv.\n        copy_files: Optional mapping of source files to destination paths\n            within `parent_directory`.\n        dependencies: Optional list of dependencies to include in the provider\n            package. If omitted, defaults to `[\"flepimop2\"]`.\n        project_name: Optional name for the provider package. Defaults to\n            \"example-provider\".\n        project_requires_python: Optional Python version specifier for the provider\n            package. Defaults to \"&gt;=3.11\".\n\n    Returns:\n        The python executable path from the newly created venv.\n\n    \"\"\"\n    parent_directory = parent_directory.resolve()\n    python = _which_python()\n    venv_python = _create_venv(python, parent_directory)\n\n    external_provider_root = parent_directory / \"external_provider\"\n    external_provider_root.mkdir(parents=True, exist_ok=True)\n    (parent_directory / \"model_output\").mkdir(parents=True, exist_ok=True)\n\n    dependencies_text = \", \".join(\n        f'\"{dep}\"'\n        for dep in _resolve_dependencies(dependencies, require_flepimop2=True)\n    )\n    pyproject_text = f\"\"\"\\\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[project]\nname = \"{project_name}\"\nversion = \"0.0.1\"\nrequires-python = \"{project_requires_python}\"\ndependencies = [{dependencies_text}]\n\n[tool.hatch.build.targets.wheel]\n# Ensure implicit namespace packages under flepimop2.* are included.\npackages = [\"src/flepimop2\"]\n\"\"\"\n    (external_provider_root / \"pyproject.toml\").write_text(pyproject_text)\n\n    # Ensure namespace package directories exist even without __init__.py\n    (external_provider_root / \"src\" / \"flepimop2\").mkdir(parents=True, exist_ok=True)\n\n    copy_files = copy_files or {}\n    for src, dest in copy_files.items():\n        dest_path = parent_directory / dest\n        dest_path.parent.mkdir(parents=True, exist_ok=True)\n        dest_path.write_text(src.read_text())\n\n    subprocess.run(  # noqa: S603\n        [\n            venv_python,\n            \"-m\",\n            \"pip\",\n            \"install\",\n            str(external_provider_root),\n        ],\n        capture_output=True,\n        text=True,\n        cwd=parent_directory,\n        check=True,\n    )\n    return venv_python\n</code></pre>"},{"location":"reference/api/testing/#flepimop2.testing.flepimop2_run","title":"<code>flepimop2_run(action, args=None, cwd=None)</code>","text":"<p>Run a flepimop2 CLI command via subprocess.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>str</code> <p>CLI action name (e.g. \"process\", \"simulate\", etc). For a full list of available actions, see <code>flepimop2 --help</code>.</p> required <code>args</code> <code>list[str] | None</code> <p>Additional command arguments to pass to the CLI command.</p> <code>None</code> <code>cwd</code> <code>Path | None</code> <p>Optional working directory for the command.</p> <code>None</code> <p>Returns:</p> Type Description <code>CompletedProcess[str]</code> <p>The completed process from running the CLI.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the action is empty.</p> Source code in <code>src/flepimop2/testing.py</code> <pre><code>def flepimop2_run(\n    action: str,\n    args: list[str] | None = None,\n    cwd: Path | None = None,\n) -&gt; subprocess.CompletedProcess[str]:\n    \"\"\"\n    Run a flepimop2 CLI command via subprocess.\n\n    Args:\n        action: CLI action name (e.g. \"process\", \"simulate\", etc). For a full list of\n            available actions, see `flepimop2 --help`.\n        args: Additional command arguments to pass to the CLI command.\n        cwd: Optional working directory for the command.\n\n    Returns:\n        The completed process from running the CLI.\n\n    Raises:\n        ValueError: If the action is empty.\n\n    \"\"\"\n    if not action:\n        msg = \"Action must be a non-empty string\"\n        raise ValueError(msg)\n\n    args = args or []\n    if cwd is not None and ((venv_bin := cwd / \".venv\" / \"bin\" / \"flepimop2\").exists()):\n        command = [str(venv_bin), action, *args]\n    else:\n        command = [\"flepimop2\", action, *args]\n\n    return subprocess.run(  # noqa: S603\n        command,\n        capture_output=True,\n        text=True,\n        cwd=cwd,\n        check=True,\n    )\n</code></pre>"},{"location":"reference/api/testing/#flepimop2.testing.project_skeleton","title":"<code>project_skeleton(parent_directory, copy_files=None, dependencies=None)</code>","text":"<p>Create a project skeleton in <code>parent_directory</code> and optionally copy files.</p> <p>Parameters:</p> Name Type Description Default <code>parent_directory</code> <code>Path</code> <p>Directory in which to create the project skeleton and venv.</p> required <code>copy_files</code> <code>dict[Path, Path] | None</code> <p>Optional mapping of source files to destination paths within <code>parent_directory</code>.</p> <code>None</code> <code>dependencies</code> <code>list[str] | None</code> <p>Optional list of dependencies to install into the venv.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The python executable path from the newly created venv.</p> Source code in <code>src/flepimop2/testing.py</code> <pre><code>def project_skeleton(\n    parent_directory: Path,\n    copy_files: dict[Path, Path] | None = None,\n    dependencies: list[str] | None = None,\n) -&gt; str:\n    \"\"\"\n    Create a project skeleton in ``parent_directory`` and optionally copy files.\n\n    Args:\n        parent_directory: Directory in which to create the project skeleton and venv.\n        copy_files: Optional mapping of source files to destination paths\n            within ``parent_directory``.\n        dependencies: Optional list of dependencies to install into the venv.\n\n    Returns:\n        The python executable path from the newly created venv.\n\n    \"\"\"\n    parent_directory = parent_directory.resolve()\n    python = _which_python()\n    venv_python = _create_venv(python, parent_directory)\n\n    if dependencies := _resolve_dependencies(dependencies, require_flepimop2=False):\n        subprocess.run(  # noqa: S603\n            [venv_python, \"-m\", \"pip\", \"install\", *dependencies],\n            capture_output=True,\n            text=True,\n            cwd=parent_directory,\n            check=True,\n        )\n\n    flepimop2_run(\"skeleton\", args=[], cwd=parent_directory)\n\n    copy_files = copy_files or {}\n    for src, dest in copy_files.items():\n        dest_path = parent_directory / dest\n        dest_path.parent.mkdir(parents=True, exist_ok=True)\n        dest_path.write_text(src.read_text())\n\n    return venv_python\n</code></pre>"},{"location":"reference/api/typing/","title":"Typing","text":""},{"location":"reference/api/typing/#flepimop2.typing","title":"<code>typing</code>","text":"<p>Custom Typing Helpers.</p> <p>This module centralizes type aliases used throughout the project and makes it easy to keep runtime imports lightweight while still providing precise type information. The goal is to express common shapes and dtypes once, so internal modules can share consistent, readable annotations without repeating NumPy typing boilerplate.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flepimop2.typing import Float64NDArray\n&gt;&gt;&gt; Float64NDArray\nnumpy.ndarray[tuple[typing.Any, ...], numpy.dtype[numpy.float64]]\n</code></pre>"},{"location":"reference/api/typing/#flepimop2.typing.Float64NDArray","title":"<code>Float64NDArray = npt.NDArray[np.float64]</code>  <code>module-attribute</code>","text":"<p>Alias for a NumPy ndarray with float64 data type.</p>"},{"location":"reference/api/typing/#flepimop2.typing.RaiseOnMissing","title":"<code>RaiseOnMissing = RaiseOnMissingType()</code>  <code>module-attribute</code>","text":"<p>Sentinel value indicating an error should be raised if a value is missing.</p>"},{"location":"reference/api/typing/#flepimop2.typing.RaiseOnMissingType","title":"<code>RaiseOnMissingType</code>","text":"<p>A sentinel type indicating an error should be raised if a value is missing.</p>"},{"location":"reference/api/typing/#flepimop2.typing.RaiseOnMissingType.__reduce__","title":"<code>__reduce__()</code>","text":"<p>Helper for pickling the <code>RaiseOnMissingType</code> singleton.</p> <p>Returns:</p> Type Description <code>Literal['RaiseOnMissing']</code> <p>The string \"RaiseOnMissing\".</p> Source code in <code>src/flepimop2/typing.py</code> <pre><code>def __reduce__(self) -&gt; Literal[\"RaiseOnMissing\"]:\n    \"\"\"\n    Helper for pickling the `RaiseOnMissingType` singleton.\n\n    Returns:\n        The string \"RaiseOnMissing\".\n    \"\"\"\n    return \"RaiseOnMissing\"\n</code></pre>"},{"location":"reference/api/typing/#flepimop2.typing.RaiseOnMissingType.__repr__","title":"<code>__repr__()</code>","text":"<p>String representation of the <code>RaiseOnMissingType</code>.</p> <p>Returns:</p> Type Description <code>Literal['RaiseOnMissing']</code> <p>The string \"RaiseOnMissing\".</p> Source code in <code>src/flepimop2/typing.py</code> <pre><code>def __repr__(self) -&gt; Literal[\"RaiseOnMissing\"]:\n    \"\"\"\n    String representation of the `RaiseOnMissingType`.\n\n    Returns:\n        The string \"RaiseOnMissing\".\n    \"\"\"\n    return \"RaiseOnMissing\"\n</code></pre>"},{"location":"reference/api/typing/#flepimop2.typing.StateChangeEnum","title":"<code>StateChangeEnum</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enumeration of types of state changes in a system.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from flepimop2.typing import StateChangeEnum\n&gt;&gt;&gt; StateChangeEnum.DELTA\n&lt;StateChangeEnum.DELTA: 'delta'&gt;\n&gt;&gt;&gt; StateChangeEnum.FLOW\n&lt;StateChangeEnum.FLOW: 'flow'&gt;\n</code></pre>"},{"location":"reference/api/typing/#flepimop2.typing.StateChangeEnum.DELTA","title":"<code>DELTA = 'delta'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The state change is described directly by the changes in the state variables, i.e. \\( x(t + \\Delta t) = x(t) + \\Delta x \\).</p>"},{"location":"reference/api/typing/#flepimop2.typing.StateChangeEnum.FLOW","title":"<code>FLOW = 'flow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The state change is described directly by the flow rates, or derivatives, of the state variables. I.e. \\( dx/dt = f(x, t) \\).</p>"},{"location":"reference/api/typing/#flepimop2.typing.StateChangeEnum.STATE","title":"<code>STATE = 'state'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The state change is described directly by the new state values, i.e. \\( x(t + \\Delta t) = x_{new} \\).</p>"}]}